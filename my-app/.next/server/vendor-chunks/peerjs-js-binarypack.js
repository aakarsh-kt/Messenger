"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/peerjs-js-binarypack";
exports.ids = ["vendor-chunks/peerjs-js-binarypack"];
exports.modules = {

/***/ "(ssr)/./node_modules/peerjs-js-binarypack/dist/binarypack.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/peerjs-js-binarypack/dist/binarypack.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Packer: () => (/* binding */ $0cfd7828ad59115f$export$b9ec4b114aa40074),\n/* harmony export */   pack: () => (/* binding */ $0cfd7828ad59115f$export$2a703dbb0cb35339),\n/* harmony export */   unpack: () => (/* binding */ $0cfd7828ad59115f$export$417857010dc9287f)\n/* harmony export */ });\nclass $e8379818650e2442$export$93654d4f2d6cd524 {\n    constructor(){\n        this.encoder = new TextEncoder();\n        this._pieces = [];\n        this._parts = [];\n    }\n    append_buffer(data) {\n        this.flush();\n        this._parts.push(data);\n    }\n    append(data) {\n        this._pieces.push(data);\n    }\n    flush() {\n        if (this._pieces.length > 0) {\n            const buf = new Uint8Array(this._pieces);\n            this._parts.push(buf);\n            this._pieces = [];\n        }\n    }\n    toArrayBuffer() {\n        const buffer = [];\n        for (const part of this._parts)buffer.push(part);\n        return $e8379818650e2442$var$concatArrayBuffers(buffer).buffer;\n    }\n}\nfunction $e8379818650e2442$var$concatArrayBuffers(bufs) {\n    let size = 0;\n    for (const buf of bufs)size += buf.byteLength;\n    const result = new Uint8Array(size);\n    let offset = 0;\n    for (const buf of bufs){\n        const view = new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n        result.set(view, offset);\n        offset += buf.byteLength;\n    }\n    return result;\n}\n\n\nfunction $0cfd7828ad59115f$export$417857010dc9287f(data) {\n    const unpacker = new $0cfd7828ad59115f$var$Unpacker(data);\n    return unpacker.unpack();\n}\nfunction $0cfd7828ad59115f$export$2a703dbb0cb35339(data) {\n    const packer = new $0cfd7828ad59115f$export$b9ec4b114aa40074();\n    const res = packer.pack(data);\n    if (res instanceof Promise) return res.then(()=>packer.getBuffer());\n    return packer.getBuffer();\n}\nclass $0cfd7828ad59115f$var$Unpacker {\n    constructor(data){\n        this.index = 0;\n        this.dataBuffer = data;\n        this.dataView = new Uint8Array(this.dataBuffer);\n        this.length = this.dataBuffer.byteLength;\n    }\n    unpack() {\n        const type = this.unpack_uint8();\n        if (type < 0x80) return type;\n        else if ((type ^ 0xe0) < 0x20) return (type ^ 0xe0) - 0x20;\n        let size;\n        if ((size = type ^ 0xa0) <= 0x0f) return this.unpack_raw(size);\n        else if ((size = type ^ 0xb0) <= 0x0f) return this.unpack_string(size);\n        else if ((size = type ^ 0x90) <= 0x0f) return this.unpack_array(size);\n        else if ((size = type ^ 0x80) <= 0x0f) return this.unpack_map(size);\n        switch(type){\n            case 0xc0:\n                return null;\n            case 0xc1:\n                return undefined;\n            case 0xc2:\n                return false;\n            case 0xc3:\n                return true;\n            case 0xca:\n                return this.unpack_float();\n            case 0xcb:\n                return this.unpack_double();\n            case 0xcc:\n                return this.unpack_uint8();\n            case 0xcd:\n                return this.unpack_uint16();\n            case 0xce:\n                return this.unpack_uint32();\n            case 0xcf:\n                return this.unpack_uint64();\n            case 0xd0:\n                return this.unpack_int8();\n            case 0xd1:\n                return this.unpack_int16();\n            case 0xd2:\n                return this.unpack_int32();\n            case 0xd3:\n                return this.unpack_int64();\n            case 0xd4:\n                return undefined;\n            case 0xd5:\n                return undefined;\n            case 0xd6:\n                return undefined;\n            case 0xd7:\n                return undefined;\n            case 0xd8:\n                size = this.unpack_uint16();\n                return this.unpack_string(size);\n            case 0xd9:\n                size = this.unpack_uint32();\n                return this.unpack_string(size);\n            case 0xda:\n                size = this.unpack_uint16();\n                return this.unpack_raw(size);\n            case 0xdb:\n                size = this.unpack_uint32();\n                return this.unpack_raw(size);\n            case 0xdc:\n                size = this.unpack_uint16();\n                return this.unpack_array(size);\n            case 0xdd:\n                size = this.unpack_uint32();\n                return this.unpack_array(size);\n            case 0xde:\n                size = this.unpack_uint16();\n                return this.unpack_map(size);\n            case 0xdf:\n                size = this.unpack_uint32();\n                return this.unpack_map(size);\n        }\n    }\n    unpack_uint8() {\n        const byte = this.dataView[this.index] & 0xff;\n        this.index++;\n        return byte;\n    }\n    unpack_uint16() {\n        const bytes = this.read(2);\n        const uint16 = (bytes[0] & 0xff) * 256 + (bytes[1] & 0xff);\n        this.index += 2;\n        return uint16;\n    }\n    unpack_uint32() {\n        const bytes = this.read(4);\n        const uint32 = ((bytes[0] * 256 + bytes[1]) * 256 + bytes[2]) * 256 + bytes[3];\n        this.index += 4;\n        return uint32;\n    }\n    unpack_uint64() {\n        const bytes = this.read(8);\n        const uint64 = ((((((bytes[0] * 256 + bytes[1]) * 256 + bytes[2]) * 256 + bytes[3]) * 256 + bytes[4]) * 256 + bytes[5]) * 256 + bytes[6]) * 256 + bytes[7];\n        this.index += 8;\n        return uint64;\n    }\n    unpack_int8() {\n        const uint8 = this.unpack_uint8();\n        return uint8 < 0x80 ? uint8 : uint8 - 256;\n    }\n    unpack_int16() {\n        const uint16 = this.unpack_uint16();\n        return uint16 < 0x8000 ? uint16 : uint16 - 65536;\n    }\n    unpack_int32() {\n        const uint32 = this.unpack_uint32();\n        return uint32 < 2 ** 31 ? uint32 : uint32 - 2 ** 32;\n    }\n    unpack_int64() {\n        const uint64 = this.unpack_uint64();\n        return uint64 < 2 ** 63 ? uint64 : uint64 - 2 ** 64;\n    }\n    unpack_raw(size) {\n        if (this.length < this.index + size) throw new Error(`BinaryPackFailure: index is out of range ${this.index} ${size} ${this.length}`);\n        const buf = this.dataBuffer.slice(this.index, this.index + size);\n        this.index += size;\n        return buf;\n    }\n    unpack_string(size) {\n        const bytes = this.read(size);\n        let i = 0;\n        let str = \"\";\n        let c;\n        let code;\n        while(i < size){\n            c = bytes[i];\n            // The length of a UTF-8 sequence is specified in the first byte:\n            // 0xxxxxxx means length 1,\n            // 110xxxxx means length 2,\n            // 1110xxxx means length 3,\n            // 11110xxx means length 4.\n            // 10xxxxxx is for non-initial bytes.\n            if (c < 0xa0) {\n                // One-byte sequence: bits 0xxxxxxx\n                code = c;\n                i++;\n            } else if ((c ^ 0xc0) < 0x20) {\n                // Two-byte sequence: bits 110xxxxx 10xxxxxx\n                code = (c & 0x1f) << 6 | bytes[i + 1] & 0x3f;\n                i += 2;\n            } else if ((c ^ 0xe0) < 0x10) {\n                // Three-byte sequence: bits 1110xxxx 10xxxxxx 10xxxxxx\n                code = (c & 0x0f) << 12 | (bytes[i + 1] & 0x3f) << 6 | bytes[i + 2] & 0x3f;\n                i += 3;\n            } else {\n                // Four-byte sequence: bits 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n                code = (c & 0x07) << 18 | (bytes[i + 1] & 0x3f) << 12 | (bytes[i + 2] & 0x3f) << 6 | bytes[i + 3] & 0x3f;\n                i += 4;\n            }\n            str += String.fromCodePoint(code);\n        }\n        this.index += size;\n        return str;\n    }\n    unpack_array(size) {\n        const objects = new Array(size);\n        for(let i = 0; i < size; i++)objects[i] = this.unpack();\n        return objects;\n    }\n    unpack_map(size) {\n        const map = {};\n        for(let i = 0; i < size; i++){\n            const key = this.unpack();\n            map[key] = this.unpack();\n        }\n        return map;\n    }\n    unpack_float() {\n        const uint32 = this.unpack_uint32();\n        const sign = uint32 >> 31;\n        const exp = (uint32 >> 23 & 0xff) - 127;\n        const fraction = uint32 & 0x7fffff | 0x800000;\n        return (sign === 0 ? 1 : -1) * fraction * 2 ** (exp - 23);\n    }\n    unpack_double() {\n        const h32 = this.unpack_uint32();\n        const l32 = this.unpack_uint32();\n        const sign = h32 >> 31;\n        const exp = (h32 >> 20 & 0x7ff) - 1023;\n        const hfrac = h32 & 0xfffff | 0x100000;\n        const frac = hfrac * 2 ** (exp - 20) + l32 * 2 ** (exp - 52);\n        return (sign === 0 ? 1 : -1) * frac;\n    }\n    read(length) {\n        const j = this.index;\n        if (j + length <= this.length) return this.dataView.subarray(j, j + length);\n        else throw new Error(\"BinaryPackFailure: read index out of range\");\n    }\n}\nclass $0cfd7828ad59115f$export$b9ec4b114aa40074 {\n    getBuffer() {\n        return this._bufferBuilder.toArrayBuffer();\n    }\n    pack(value) {\n        if (typeof value === \"string\") this.pack_string(value);\n        else if (typeof value === \"number\") {\n            if (Math.floor(value) === value) this.pack_integer(value);\n            else this.pack_double(value);\n        } else if (typeof value === \"boolean\") {\n            if (value === true) this._bufferBuilder.append(0xc3);\n            else if (value === false) this._bufferBuilder.append(0xc2);\n        } else if (value === undefined) this._bufferBuilder.append(0xc0);\n        else if (typeof value === \"object\") {\n            if (value === null) this._bufferBuilder.append(0xc0);\n            else {\n                const constructor = value.constructor;\n                if (value instanceof Array) {\n                    const res = this.pack_array(value);\n                    if (res instanceof Promise) return res.then(()=>this._bufferBuilder.flush());\n                } else if (value instanceof ArrayBuffer) this.pack_bin(new Uint8Array(value));\n                else if (\"BYTES_PER_ELEMENT\" in value) {\n                    const v = value;\n                    this.pack_bin(new Uint8Array(v.buffer, v.byteOffset, v.byteLength));\n                } else if (value instanceof Date) this.pack_string(value.toString());\n                else if (value instanceof Blob) return value.arrayBuffer().then((buffer)=>{\n                    this.pack_bin(new Uint8Array(buffer));\n                    this._bufferBuilder.flush();\n                });\n                else if (constructor == Object || constructor.toString().startsWith(\"class\")) {\n                    const res = this.pack_object(value);\n                    if (res instanceof Promise) return res.then(()=>this._bufferBuilder.flush());\n                } else throw new Error(`Type \"${constructor.toString()}\" not yet supported`);\n            }\n        } else throw new Error(`Type \"${typeof value}\" not yet supported`);\n        this._bufferBuilder.flush();\n    }\n    pack_bin(blob) {\n        const length = blob.length;\n        if (length <= 0x0f) this.pack_uint8(0xa0 + length);\n        else if (length <= 0xffff) {\n            this._bufferBuilder.append(0xda);\n            this.pack_uint16(length);\n        } else if (length <= 0xffffffff) {\n            this._bufferBuilder.append(0xdb);\n            this.pack_uint32(length);\n        } else throw new Error(\"Invalid length\");\n        this._bufferBuilder.append_buffer(blob);\n    }\n    pack_string(str) {\n        const encoded = this._textEncoder.encode(str);\n        const length = encoded.length;\n        if (length <= 0x0f) this.pack_uint8(0xb0 + length);\n        else if (length <= 0xffff) {\n            this._bufferBuilder.append(0xd8);\n            this.pack_uint16(length);\n        } else if (length <= 0xffffffff) {\n            this._bufferBuilder.append(0xd9);\n            this.pack_uint32(length);\n        } else throw new Error(\"Invalid length\");\n        this._bufferBuilder.append_buffer(encoded);\n    }\n    pack_array(ary) {\n        const length = ary.length;\n        if (length <= 0x0f) this.pack_uint8(0x90 + length);\n        else if (length <= 0xffff) {\n            this._bufferBuilder.append(0xdc);\n            this.pack_uint16(length);\n        } else if (length <= 0xffffffff) {\n            this._bufferBuilder.append(0xdd);\n            this.pack_uint32(length);\n        } else throw new Error(\"Invalid length\");\n        const packNext = (index)=>{\n            if (index < length) {\n                const res = this.pack(ary[index]);\n                if (res instanceof Promise) return res.then(()=>packNext(index + 1));\n                return packNext(index + 1);\n            }\n        };\n        return packNext(0);\n    }\n    pack_integer(num) {\n        if (num >= -32 && num <= 0x7f) this._bufferBuilder.append(num & 0xff);\n        else if (num >= 0x00 && num <= 0xff) {\n            this._bufferBuilder.append(0xcc);\n            this.pack_uint8(num);\n        } else if (num >= -128 && num <= 0x7f) {\n            this._bufferBuilder.append(0xd0);\n            this.pack_int8(num);\n        } else if (num >= 0x0000 && num <= 0xffff) {\n            this._bufferBuilder.append(0xcd);\n            this.pack_uint16(num);\n        } else if (num >= -32768 && num <= 0x7fff) {\n            this._bufferBuilder.append(0xd1);\n            this.pack_int16(num);\n        } else if (num >= 0x00000000 && num <= 0xffffffff) {\n            this._bufferBuilder.append(0xce);\n            this.pack_uint32(num);\n        } else if (num >= -2147483648 && num <= 0x7fffffff) {\n            this._bufferBuilder.append(0xd2);\n            this.pack_int32(num);\n        } else if (num >= -9223372036854776000 && num <= 0x7fffffffffffffff) {\n            this._bufferBuilder.append(0xd3);\n            this.pack_int64(num);\n        } else if (num >= 0x0000000000000000 && num <= 0xffffffffffffffff) {\n            this._bufferBuilder.append(0xcf);\n            this.pack_uint64(num);\n        } else throw new Error(\"Invalid integer\");\n    }\n    pack_double(num) {\n        let sign = 0;\n        if (num < 0) {\n            sign = 1;\n            num = -num;\n        }\n        const exp = Math.floor(Math.log(num) / Math.LN2);\n        const frac0 = num / 2 ** exp - 1;\n        const frac1 = Math.floor(frac0 * 2 ** 52);\n        const b32 = 2 ** 32;\n        const h32 = sign << 31 | exp + 1023 << 20 | frac1 / b32 & 0x0fffff;\n        const l32 = frac1 % b32;\n        this._bufferBuilder.append(0xcb);\n        this.pack_int32(h32);\n        this.pack_int32(l32);\n    }\n    pack_object(obj) {\n        const keys = Object.keys(obj);\n        const length = keys.length;\n        if (length <= 0x0f) this.pack_uint8(0x80 + length);\n        else if (length <= 0xffff) {\n            this._bufferBuilder.append(0xde);\n            this.pack_uint16(length);\n        } else if (length <= 0xffffffff) {\n            this._bufferBuilder.append(0xdf);\n            this.pack_uint32(length);\n        } else throw new Error(\"Invalid length\");\n        const packNext = (index)=>{\n            if (index < keys.length) {\n                const prop = keys[index];\n                // eslint-disable-next-line no-prototype-builtins\n                if (obj.hasOwnProperty(prop)) {\n                    this.pack(prop);\n                    const res = this.pack(obj[prop]);\n                    if (res instanceof Promise) return res.then(()=>packNext(index + 1));\n                }\n                return packNext(index + 1);\n            }\n        };\n        return packNext(0);\n    }\n    pack_uint8(num) {\n        this._bufferBuilder.append(num);\n    }\n    pack_uint16(num) {\n        this._bufferBuilder.append(num >> 8);\n        this._bufferBuilder.append(num & 0xff);\n    }\n    pack_uint32(num) {\n        const n = num & 0xffffffff;\n        this._bufferBuilder.append((n & 0xff000000) >>> 24);\n        this._bufferBuilder.append((n & 0x00ff0000) >>> 16);\n        this._bufferBuilder.append((n & 0x0000ff00) >>> 8);\n        this._bufferBuilder.append(n & 0x000000ff);\n    }\n    pack_uint64(num) {\n        const high = num / 2 ** 32;\n        const low = num % 2 ** 32;\n        this._bufferBuilder.append((high & 0xff000000) >>> 24);\n        this._bufferBuilder.append((high & 0x00ff0000) >>> 16);\n        this._bufferBuilder.append((high & 0x0000ff00) >>> 8);\n        this._bufferBuilder.append(high & 0x000000ff);\n        this._bufferBuilder.append((low & 0xff000000) >>> 24);\n        this._bufferBuilder.append((low & 0x00ff0000) >>> 16);\n        this._bufferBuilder.append((low & 0x0000ff00) >>> 8);\n        this._bufferBuilder.append(low & 0x000000ff);\n    }\n    pack_int8(num) {\n        this._bufferBuilder.append(num & 0xff);\n    }\n    pack_int16(num) {\n        this._bufferBuilder.append((num & 0xff00) >> 8);\n        this._bufferBuilder.append(num & 0xff);\n    }\n    pack_int32(num) {\n        this._bufferBuilder.append(num >>> 24 & 0xff);\n        this._bufferBuilder.append((num & 0x00ff0000) >>> 16);\n        this._bufferBuilder.append((num & 0x0000ff00) >>> 8);\n        this._bufferBuilder.append(num & 0x000000ff);\n    }\n    pack_int64(num) {\n        const high = Math.floor(num / 2 ** 32);\n        const low = num % 2 ** 32;\n        this._bufferBuilder.append((high & 0xff000000) >>> 24);\n        this._bufferBuilder.append((high & 0x00ff0000) >>> 16);\n        this._bufferBuilder.append((high & 0x0000ff00) >>> 8);\n        this._bufferBuilder.append(high & 0x000000ff);\n        this._bufferBuilder.append((low & 0xff000000) >>> 24);\n        this._bufferBuilder.append((low & 0x00ff0000) >>> 16);\n        this._bufferBuilder.append((low & 0x0000ff00) >>> 8);\n        this._bufferBuilder.append(low & 0x000000ff);\n    }\n    constructor(){\n        this._bufferBuilder = new (0, $e8379818650e2442$export$93654d4f2d6cd524)();\n        this._textEncoder = new TextEncoder();\n    }\n}\n\n\n\n//# sourceMappingURL=binarypack.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGVlcmpzLWpzLWJpbmFyeXBhY2svZGlzdC9iaW5hcnlwYWNrLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsWUFBWSxFQUFFLE1BQU0sRUFBRSxZQUFZO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQThCLHVCQUF1QjtBQUN2RTtBQUNBLFVBQVUsOEJBQThCLGFBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdxSztBQUNySyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9wZWVyanMtanMtYmluYXJ5cGFjay9kaXN0L2JpbmFyeXBhY2subWpzPzVlNjciXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgJGU4Mzc5ODE4NjUwZTI0NDIkZXhwb3J0JDkzNjU0ZDRmMmQ2Y2Q1MjQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICB0aGlzLl9waWVjZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fcGFydHMgPSBbXTtcbiAgICB9XG4gICAgYXBwZW5kX2J1ZmZlcihkYXRhKSB7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgdGhpcy5fcGFydHMucHVzaChkYXRhKTtcbiAgICB9XG4gICAgYXBwZW5kKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fcGllY2VzLnB1c2goZGF0YSk7XG4gICAgfVxuICAgIGZsdXNoKCkge1xuICAgICAgICBpZiAodGhpcy5fcGllY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMuX3BpZWNlcyk7XG4gICAgICAgICAgICB0aGlzLl9wYXJ0cy5wdXNoKGJ1Zik7XG4gICAgICAgICAgICB0aGlzLl9waWVjZXMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0FycmF5QnVmZmVyKCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHRoaXMuX3BhcnRzKWJ1ZmZlci5wdXNoKHBhcnQpO1xuICAgICAgICByZXR1cm4gJGU4Mzc5ODE4NjUwZTI0NDIkdmFyJGNvbmNhdEFycmF5QnVmZmVycyhidWZmZXIpLmJ1ZmZlcjtcbiAgICB9XG59XG5mdW5jdGlvbiAkZTgzNzk4MTg2NTBlMjQ0MiR2YXIkY29uY2F0QXJyYXlCdWZmZXJzKGJ1ZnMpIHtcbiAgICBsZXQgc2l6ZSA9IDA7XG4gICAgZm9yIChjb25zdCBidWYgb2YgYnVmcylzaXplICs9IGJ1Zi5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAoY29uc3QgYnVmIG9mIGJ1ZnMpe1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmVzdWx0LnNldCh2aWV3LCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gYnVmLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gJDBjZmQ3ODI4YWQ1OTExNWYkZXhwb3J0JDQxNzg1NzAxMGRjOTI4N2YoZGF0YSkge1xuICAgIGNvbnN0IHVucGFja2VyID0gbmV3ICQwY2ZkNzgyOGFkNTkxMTVmJHZhciRVbnBhY2tlcihkYXRhKTtcbiAgICByZXR1cm4gdW5wYWNrZXIudW5wYWNrKCk7XG59XG5mdW5jdGlvbiAkMGNmZDc4MjhhZDU5MTE1ZiRleHBvcnQkMmE3MDNkYmIwY2IzNTMzOShkYXRhKSB7XG4gICAgY29uc3QgcGFja2VyID0gbmV3ICQwY2ZkNzgyOGFkNTkxMTVmJGV4cG9ydCRiOWVjNGIxMTRhYTQwMDc0KCk7XG4gICAgY29uc3QgcmVzID0gcGFja2VyLnBhY2soZGF0YSk7XG4gICAgaWYgKHJlcyBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiByZXMudGhlbigoKT0+cGFja2VyLmdldEJ1ZmZlcigpKTtcbiAgICByZXR1cm4gcGFja2VyLmdldEJ1ZmZlcigpO1xufVxuY2xhc3MgJDBjZmQ3ODI4YWQ1OTExNWYkdmFyJFVucGFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKXtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuZGF0YUJ1ZmZlciA9IGRhdGE7XG4gICAgICAgIHRoaXMuZGF0YVZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGFCdWZmZXIpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMuZGF0YUJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICB1bnBhY2soKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnVucGFja191aW50OCgpO1xuICAgICAgICBpZiAodHlwZSA8IDB4ODApIHJldHVybiB0eXBlO1xuICAgICAgICBlbHNlIGlmICgodHlwZSBeIDB4ZTApIDwgMHgyMCkgcmV0dXJuICh0eXBlIF4gMHhlMCkgLSAweDIwO1xuICAgICAgICBsZXQgc2l6ZTtcbiAgICAgICAgaWYgKChzaXplID0gdHlwZSBeIDB4YTApIDw9IDB4MGYpIHJldHVybiB0aGlzLnVucGFja19yYXcoc2l6ZSk7XG4gICAgICAgIGVsc2UgaWYgKChzaXplID0gdHlwZSBeIDB4YjApIDw9IDB4MGYpIHJldHVybiB0aGlzLnVucGFja19zdHJpbmcoc2l6ZSk7XG4gICAgICAgIGVsc2UgaWYgKChzaXplID0gdHlwZSBeIDB4OTApIDw9IDB4MGYpIHJldHVybiB0aGlzLnVucGFja19hcnJheShzaXplKTtcbiAgICAgICAgZWxzZSBpZiAoKHNpemUgPSB0eXBlIF4gMHg4MCkgPD0gMHgwZikgcmV0dXJuIHRoaXMudW5wYWNrX21hcChzaXplKTtcbiAgICAgICAgc3dpdGNoKHR5cGUpe1xuICAgICAgICAgICAgY2FzZSAweGMwOlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY2FzZSAweGMxOlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYXNlIDB4YzI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSAweGMzOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSAweGNhOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVucGFja19mbG9hdCgpO1xuICAgICAgICAgICAgY2FzZSAweGNiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVucGFja19kb3VibGUoKTtcbiAgICAgICAgICAgIGNhc2UgMHhjYzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnBhY2tfdWludDgoKTtcbiAgICAgICAgICAgIGNhc2UgMHhjZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnBhY2tfdWludDE2KCk7XG4gICAgICAgICAgICBjYXNlIDB4Y2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX3VpbnQzMigpO1xuICAgICAgICAgICAgY2FzZSAweGNmOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVucGFja191aW50NjQoKTtcbiAgICAgICAgICAgIGNhc2UgMHhkMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnBhY2tfaW50OCgpO1xuICAgICAgICAgICAgY2FzZSAweGQxOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVucGFja19pbnQxNigpO1xuICAgICAgICAgICAgY2FzZSAweGQyOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVucGFja19pbnQzMigpO1xuICAgICAgICAgICAgY2FzZSAweGQzOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVucGFja19pbnQ2NCgpO1xuICAgICAgICAgICAgY2FzZSAweGQ0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYXNlIDB4ZDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhc2UgMHhkNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FzZSAweGQ3OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYXNlIDB4ZDg6XG4gICAgICAgICAgICAgICAgc2l6ZSA9IHRoaXMudW5wYWNrX3VpbnQxNigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVucGFja19zdHJpbmcoc2l6ZSk7XG4gICAgICAgICAgICBjYXNlIDB4ZDk6XG4gICAgICAgICAgICAgICAgc2l6ZSA9IHRoaXMudW5wYWNrX3VpbnQzMigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVucGFja19zdHJpbmcoc2l6ZSk7XG4gICAgICAgICAgICBjYXNlIDB4ZGE6XG4gICAgICAgICAgICAgICAgc2l6ZSA9IHRoaXMudW5wYWNrX3VpbnQxNigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVucGFja19yYXcoc2l6ZSk7XG4gICAgICAgICAgICBjYXNlIDB4ZGI6XG4gICAgICAgICAgICAgICAgc2l6ZSA9IHRoaXMudW5wYWNrX3VpbnQzMigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVucGFja19yYXcoc2l6ZSk7XG4gICAgICAgICAgICBjYXNlIDB4ZGM6XG4gICAgICAgICAgICAgICAgc2l6ZSA9IHRoaXMudW5wYWNrX3VpbnQxNigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVucGFja19hcnJheShzaXplKTtcbiAgICAgICAgICAgIGNhc2UgMHhkZDpcbiAgICAgICAgICAgICAgICBzaXplID0gdGhpcy51bnBhY2tfdWludDMyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX2FycmF5KHNpemUpO1xuICAgICAgICAgICAgY2FzZSAweGRlOlxuICAgICAgICAgICAgICAgIHNpemUgPSB0aGlzLnVucGFja191aW50MTYoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnBhY2tfbWFwKHNpemUpO1xuICAgICAgICAgICAgY2FzZSAweGRmOlxuICAgICAgICAgICAgICAgIHNpemUgPSB0aGlzLnVucGFja191aW50MzIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnBhY2tfbWFwKHNpemUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVucGFja191aW50OCgpIHtcbiAgICAgICAgY29uc3QgYnl0ZSA9IHRoaXMuZGF0YVZpZXdbdGhpcy5pbmRleF0gJiAweGZmO1xuICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIHJldHVybiBieXRlO1xuICAgIH1cbiAgICB1bnBhY2tfdWludDE2KCkge1xuICAgICAgICBjb25zdCBieXRlcyA9IHRoaXMucmVhZCgyKTtcbiAgICAgICAgY29uc3QgdWludDE2ID0gKGJ5dGVzWzBdICYgMHhmZikgKiAyNTYgKyAoYnl0ZXNbMV0gJiAweGZmKTtcbiAgICAgICAgdGhpcy5pbmRleCArPSAyO1xuICAgICAgICByZXR1cm4gdWludDE2O1xuICAgIH1cbiAgICB1bnBhY2tfdWludDMyKCkge1xuICAgICAgICBjb25zdCBieXRlcyA9IHRoaXMucmVhZCg0KTtcbiAgICAgICAgY29uc3QgdWludDMyID0gKChieXRlc1swXSAqIDI1NiArIGJ5dGVzWzFdKSAqIDI1NiArIGJ5dGVzWzJdKSAqIDI1NiArIGJ5dGVzWzNdO1xuICAgICAgICB0aGlzLmluZGV4ICs9IDQ7XG4gICAgICAgIHJldHVybiB1aW50MzI7XG4gICAgfVxuICAgIHVucGFja191aW50NjQoKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gdGhpcy5yZWFkKDgpO1xuICAgICAgICBjb25zdCB1aW50NjQgPSAoKCgoKChieXRlc1swXSAqIDI1NiArIGJ5dGVzWzFdKSAqIDI1NiArIGJ5dGVzWzJdKSAqIDI1NiArIGJ5dGVzWzNdKSAqIDI1NiArIGJ5dGVzWzRdKSAqIDI1NiArIGJ5dGVzWzVdKSAqIDI1NiArIGJ5dGVzWzZdKSAqIDI1NiArIGJ5dGVzWzddO1xuICAgICAgICB0aGlzLmluZGV4ICs9IDg7XG4gICAgICAgIHJldHVybiB1aW50NjQ7XG4gICAgfVxuICAgIHVucGFja19pbnQ4KCkge1xuICAgICAgICBjb25zdCB1aW50OCA9IHRoaXMudW5wYWNrX3VpbnQ4KCk7XG4gICAgICAgIHJldHVybiB1aW50OCA8IDB4ODAgPyB1aW50OCA6IHVpbnQ4IC0gMjU2O1xuICAgIH1cbiAgICB1bnBhY2tfaW50MTYoKSB7XG4gICAgICAgIGNvbnN0IHVpbnQxNiA9IHRoaXMudW5wYWNrX3VpbnQxNigpO1xuICAgICAgICByZXR1cm4gdWludDE2IDwgMHg4MDAwID8gdWludDE2IDogdWludDE2IC0gNjU1MzY7XG4gICAgfVxuICAgIHVucGFja19pbnQzMigpIHtcbiAgICAgICAgY29uc3QgdWludDMyID0gdGhpcy51bnBhY2tfdWludDMyKCk7XG4gICAgICAgIHJldHVybiB1aW50MzIgPCAyICoqIDMxID8gdWludDMyIDogdWludDMyIC0gMiAqKiAzMjtcbiAgICB9XG4gICAgdW5wYWNrX2ludDY0KCkge1xuICAgICAgICBjb25zdCB1aW50NjQgPSB0aGlzLnVucGFja191aW50NjQoKTtcbiAgICAgICAgcmV0dXJuIHVpbnQ2NCA8IDIgKiogNjMgPyB1aW50NjQgOiB1aW50NjQgLSAyICoqIDY0O1xuICAgIH1cbiAgICB1bnBhY2tfcmF3KHNpemUpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIDwgdGhpcy5pbmRleCArIHNpemUpIHRocm93IG5ldyBFcnJvcihgQmluYXJ5UGFja0ZhaWx1cmU6IGluZGV4IGlzIG91dCBvZiByYW5nZSAke3RoaXMuaW5kZXh9ICR7c2l6ZX0gJHt0aGlzLmxlbmd0aH1gKTtcbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5kYXRhQnVmZmVyLnNsaWNlKHRoaXMuaW5kZXgsIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICAgICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICB1bnBhY2tfc3RyaW5nKHNpemUpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLnJlYWQoc2l6ZSk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgICAgIGxldCBjO1xuICAgICAgICBsZXQgY29kZTtcbiAgICAgICAgd2hpbGUoaSA8IHNpemUpe1xuICAgICAgICAgICAgYyA9IGJ5dGVzW2ldO1xuICAgICAgICAgICAgLy8gVGhlIGxlbmd0aCBvZiBhIFVURi04IHNlcXVlbmNlIGlzIHNwZWNpZmllZCBpbiB0aGUgZmlyc3QgYnl0ZTpcbiAgICAgICAgICAgIC8vIDB4eHh4eHh4IG1lYW5zIGxlbmd0aCAxLFxuICAgICAgICAgICAgLy8gMTEweHh4eHggbWVhbnMgbGVuZ3RoIDIsXG4gICAgICAgICAgICAvLyAxMTEweHh4eCBtZWFucyBsZW5ndGggMyxcbiAgICAgICAgICAgIC8vIDExMTEweHh4IG1lYW5zIGxlbmd0aCA0LlxuICAgICAgICAgICAgLy8gMTB4eHh4eHggaXMgZm9yIG5vbi1pbml0aWFsIGJ5dGVzLlxuICAgICAgICAgICAgaWYgKGMgPCAweGEwKSB7XG4gICAgICAgICAgICAgICAgLy8gT25lLWJ5dGUgc2VxdWVuY2U6IGJpdHMgMHh4eHh4eHhcbiAgICAgICAgICAgICAgICBjb2RlID0gYztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChjIF4gMHhjMCkgPCAweDIwKSB7XG4gICAgICAgICAgICAgICAgLy8gVHdvLWJ5dGUgc2VxdWVuY2U6IGJpdHMgMTEweHh4eHggMTB4eHh4eHhcbiAgICAgICAgICAgICAgICBjb2RlID0gKGMgJiAweDFmKSA8PCA2IHwgYnl0ZXNbaSArIDFdICYgMHgzZjtcbiAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChjIF4gMHhlMCkgPCAweDEwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhyZWUtYnl0ZSBzZXF1ZW5jZTogYml0cyAxMTEweHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgICAgICAgICAgIGNvZGUgPSAoYyAmIDB4MGYpIDw8IDEyIHwgKGJ5dGVzW2kgKyAxXSAmIDB4M2YpIDw8IDYgfCBieXRlc1tpICsgMl0gJiAweDNmO1xuICAgICAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRm91ci1ieXRlIHNlcXVlbmNlOiBiaXRzIDExMTEweHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgICAgICAgICAgY29kZSA9IChjICYgMHgwNykgPDwgMTggfCAoYnl0ZXNbaSArIDFdICYgMHgzZikgPDwgMTIgfCAoYnl0ZXNbaSArIDJdICYgMHgzZikgPDwgNiB8IGJ5dGVzW2kgKyAzXSAmIDB4M2Y7XG4gICAgICAgICAgICAgICAgaSArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5kZXggKz0gc2l6ZTtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgdW5wYWNrX2FycmF5KHNpemUpIHtcbiAgICAgICAgY29uc3Qgb2JqZWN0cyA9IG5ldyBBcnJheShzaXplKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKylvYmplY3RzW2ldID0gdGhpcy51bnBhY2soKTtcbiAgICAgICAgcmV0dXJuIG9iamVjdHM7XG4gICAgfVxuICAgIHVucGFja19tYXAoc2l6ZSkge1xuICAgICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLnVucGFjaygpO1xuICAgICAgICAgICAgbWFwW2tleV0gPSB0aGlzLnVucGFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIHVucGFja19mbG9hdCgpIHtcbiAgICAgICAgY29uc3QgdWludDMyID0gdGhpcy51bnBhY2tfdWludDMyKCk7XG4gICAgICAgIGNvbnN0IHNpZ24gPSB1aW50MzIgPj4gMzE7XG4gICAgICAgIGNvbnN0IGV4cCA9ICh1aW50MzIgPj4gMjMgJiAweGZmKSAtIDEyNztcbiAgICAgICAgY29uc3QgZnJhY3Rpb24gPSB1aW50MzIgJiAweDdmZmZmZiB8IDB4ODAwMDAwO1xuICAgICAgICByZXR1cm4gKHNpZ24gPT09IDAgPyAxIDogLTEpICogZnJhY3Rpb24gKiAyICoqIChleHAgLSAyMyk7XG4gICAgfVxuICAgIHVucGFja19kb3VibGUoKSB7XG4gICAgICAgIGNvbnN0IGgzMiA9IHRoaXMudW5wYWNrX3VpbnQzMigpO1xuICAgICAgICBjb25zdCBsMzIgPSB0aGlzLnVucGFja191aW50MzIoKTtcbiAgICAgICAgY29uc3Qgc2lnbiA9IGgzMiA+PiAzMTtcbiAgICAgICAgY29uc3QgZXhwID0gKGgzMiA+PiAyMCAmIDB4N2ZmKSAtIDEwMjM7XG4gICAgICAgIGNvbnN0IGhmcmFjID0gaDMyICYgMHhmZmZmZiB8IDB4MTAwMDAwO1xuICAgICAgICBjb25zdCBmcmFjID0gaGZyYWMgKiAyICoqIChleHAgLSAyMCkgKyBsMzIgKiAyICoqIChleHAgLSA1Mik7XG4gICAgICAgIHJldHVybiAoc2lnbiA9PT0gMCA/IDEgOiAtMSkgKiBmcmFjO1xuICAgIH1cbiAgICByZWFkKGxlbmd0aCkge1xuICAgICAgICBjb25zdCBqID0gdGhpcy5pbmRleDtcbiAgICAgICAgaWYgKGogKyBsZW5ndGggPD0gdGhpcy5sZW5ndGgpIHJldHVybiB0aGlzLmRhdGFWaWV3LnN1YmFycmF5KGosIGogKyBsZW5ndGgpO1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihcIkJpbmFyeVBhY2tGYWlsdXJlOiByZWFkIGluZGV4IG91dCBvZiByYW5nZVwiKTtcbiAgICB9XG59XG5jbGFzcyAkMGNmZDc4MjhhZDU5MTE1ZiRleHBvcnQkYjllYzRiMTE0YWE0MDA3NCB7XG4gICAgZ2V0QnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyQnVpbGRlci50b0FycmF5QnVmZmVyKCk7XG4gICAgfVxuICAgIHBhY2sodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikgdGhpcy5wYWNrX3N0cmluZyh2YWx1ZSk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSkgdGhpcy5wYWNrX2ludGVnZXIodmFsdWUpO1xuICAgICAgICAgICAgZWxzZSB0aGlzLnBhY2tfZG91YmxlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4YzMpO1xuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IGZhbHNlKSB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgweGMyKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgweGMwKTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4YzApO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uc3RydWN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLnBhY2tfYXJyYXkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIHJlcy50aGVuKCgpPT50aGlzLl9idWZmZXJCdWlsZGVyLmZsdXNoKCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgdGhpcy5wYWNrX2JpbihuZXcgVWludDhBcnJheSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwiQllURVNfUEVSX0VMRU1FTlRcIiBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFja19iaW4obmV3IFVpbnQ4QXJyYXkodi5idWZmZXIsIHYuYnl0ZU9mZnNldCwgdi5ieXRlTGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHRoaXMucGFja19zdHJpbmcodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBCbG9iKSByZXR1cm4gdmFsdWUuYXJyYXlCdWZmZXIoKS50aGVuKChidWZmZXIpPT57XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFja19iaW4obmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuZmx1c2goKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb25zdHJ1Y3RvciA9PSBPYmplY3QgfHwgY29uc3RydWN0b3IudG9TdHJpbmcoKS5zdGFydHNXaXRoKFwiY2xhc3NcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gdGhpcy5wYWNrX29iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gcmVzLnRoZW4oKCk9PnRoaXMuX2J1ZmZlckJ1aWxkZXIuZmx1c2goKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHRocm93IG5ldyBFcnJvcihgVHlwZSBcIiR7Y29uc3RydWN0b3IudG9TdHJpbmcoKX1cIiBub3QgeWV0IHN1cHBvcnRlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKGBUeXBlIFwiJHt0eXBlb2YgdmFsdWV9XCIgbm90IHlldCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5mbHVzaCgpO1xuICAgIH1cbiAgICBwYWNrX2JpbihibG9iKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGJsb2IubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoIDw9IDB4MGYpIHRoaXMucGFja191aW50OCgweGEwICsgbGVuZ3RoKTtcbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoIDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkYSk7XG4gICAgICAgICAgICB0aGlzLnBhY2tfdWludDE2KGxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoIDw9IDB4ZmZmZmZmZmYpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZGIpO1xuICAgICAgICAgICAgdGhpcy5wYWNrX3VpbnQzMihsZW5ndGgpO1xuICAgICAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsZW5ndGhcIik7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kX2J1ZmZlcihibG9iKTtcbiAgICB9XG4gICAgcGFja19zdHJpbmcoc3RyKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZWQgPSB0aGlzLl90ZXh0RW5jb2Rlci5lbmNvZGUoc3RyKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZW5jb2RlZC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPD0gMHgwZikgdGhpcy5wYWNrX3VpbnQ4KDB4YjAgKyBsZW5ndGgpO1xuICAgICAgICBlbHNlIGlmIChsZW5ndGggPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgweGQ4KTtcbiAgICAgICAgICAgIHRoaXMucGFja191aW50MTYobGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGggPD0gMHhmZmZmZmZmZikge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkOSk7XG4gICAgICAgICAgICB0aGlzLnBhY2tfdWludDMyKGxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxlbmd0aFwiKTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmRfYnVmZmVyKGVuY29kZWQpO1xuICAgIH1cbiAgICBwYWNrX2FycmF5KGFyeSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBhcnkubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoIDw9IDB4MGYpIHRoaXMucGFja191aW50OCgweDkwICsgbGVuZ3RoKTtcbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoIDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkYyk7XG4gICAgICAgICAgICB0aGlzLnBhY2tfdWludDE2KGxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoIDw9IDB4ZmZmZmZmZmYpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZGQpO1xuICAgICAgICAgICAgdGhpcy5wYWNrX3VpbnQzMihsZW5ndGgpO1xuICAgICAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsZW5ndGhcIik7XG4gICAgICAgIGNvbnN0IHBhY2tOZXh0ID0gKGluZGV4KT0+e1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gdGhpcy5wYWNrKGFyeVtpbmRleF0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gcmVzLnRoZW4oKCk9PnBhY2tOZXh0KGluZGV4ICsgMSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYWNrTmV4dChpbmRleCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGFja05leHQoMCk7XG4gICAgfVxuICAgIHBhY2tfaW50ZWdlcihudW0pIHtcbiAgICAgICAgaWYgKG51bSA+PSAtMzIgJiYgbnVtIDw9IDB4N2YpIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKG51bSAmIDB4ZmYpO1xuICAgICAgICBlbHNlIGlmIChudW0gPj0gMHgwMCAmJiBudW0gPD0gMHhmZikge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhjYyk7XG4gICAgICAgICAgICB0aGlzLnBhY2tfdWludDgobnVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChudW0gPj0gLTEyOCAmJiBudW0gPD0gMHg3Zikge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkMCk7XG4gICAgICAgICAgICB0aGlzLnBhY2tfaW50OChudW0pO1xuICAgICAgICB9IGVsc2UgaWYgKG51bSA+PSAweDAwMDAgJiYgbnVtIDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhjZCk7XG4gICAgICAgICAgICB0aGlzLnBhY2tfdWludDE2KG51bSk7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtID49IC0zMjc2OCAmJiBudW0gPD0gMHg3ZmZmKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgweGQxKTtcbiAgICAgICAgICAgIHRoaXMucGFja19pbnQxNihudW0pO1xuICAgICAgICB9IGVsc2UgaWYgKG51bSA+PSAweDAwMDAwMDAwICYmIG51bSA8PSAweGZmZmZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgweGNlKTtcbiAgICAgICAgICAgIHRoaXMucGFja191aW50MzIobnVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChudW0gPj0gLTIxNDc0ODM2NDggJiYgbnVtIDw9IDB4N2ZmZmZmZmYpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZDIpO1xuICAgICAgICAgICAgdGhpcy5wYWNrX2ludDMyKG51bSk7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtID49IC05MjIzMzcyMDM2ODU0Nzc2MDAwICYmIG51bSA8PSAweDdmZmZmZmZmZmZmZmZmZmYpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZDMpO1xuICAgICAgICAgICAgdGhpcy5wYWNrX2ludDY0KG51bSk7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtID49IDB4MDAwMDAwMDAwMDAwMDAwMCAmJiBudW0gPD0gMHhmZmZmZmZmZmZmZmZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgweGNmKTtcbiAgICAgICAgICAgIHRoaXMucGFja191aW50NjQobnVtKTtcbiAgICAgICAgfSBlbHNlIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW50ZWdlclwiKTtcbiAgICB9XG4gICAgcGFja19kb3VibGUobnVtKSB7XG4gICAgICAgIGxldCBzaWduID0gMDtcbiAgICAgICAgaWYgKG51bSA8IDApIHtcbiAgICAgICAgICAgIHNpZ24gPSAxO1xuICAgICAgICAgICAgbnVtID0gLW51bTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHAgPSBNYXRoLmZsb29yKE1hdGgubG9nKG51bSkgLyBNYXRoLkxOMik7XG4gICAgICAgIGNvbnN0IGZyYWMwID0gbnVtIC8gMiAqKiBleHAgLSAxO1xuICAgICAgICBjb25zdCBmcmFjMSA9IE1hdGguZmxvb3IoZnJhYzAgKiAyICoqIDUyKTtcbiAgICAgICAgY29uc3QgYjMyID0gMiAqKiAzMjtcbiAgICAgICAgY29uc3QgaDMyID0gc2lnbiA8PCAzMSB8IGV4cCArIDEwMjMgPDwgMjAgfCBmcmFjMSAvIGIzMiAmIDB4MGZmZmZmO1xuICAgICAgICBjb25zdCBsMzIgPSBmcmFjMSAlIGIzMjtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhjYik7XG4gICAgICAgIHRoaXMucGFja19pbnQzMihoMzIpO1xuICAgICAgICB0aGlzLnBhY2tfaW50MzIobDMyKTtcbiAgICB9XG4gICAgcGFja19vYmplY3Qob2JqKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8PSAweDBmKSB0aGlzLnBhY2tfdWludDgoMHg4MCArIGxlbmd0aCk7XG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aCA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZGUpO1xuICAgICAgICAgICAgdGhpcy5wYWNrX3VpbnQxNihsZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA8PSAweGZmZmZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgweGRmKTtcbiAgICAgICAgICAgIHRoaXMucGFja191aW50MzIobGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbGVuZ3RoXCIpO1xuICAgICAgICBjb25zdCBwYWNrTmV4dCA9IChpbmRleCk9PntcbiAgICAgICAgICAgIGlmIChpbmRleCA8IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IGtleXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFjayhwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gdGhpcy5wYWNrKG9ialtwcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gcmVzLnRoZW4oKCk9PnBhY2tOZXh0KGluZGV4ICsgMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFja05leHQoaW5kZXggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBhY2tOZXh0KDApO1xuICAgIH1cbiAgICBwYWNrX3VpbnQ4KG51bSkge1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZChudW0pO1xuICAgIH1cbiAgICBwYWNrX3VpbnQxNihudW0pIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQobnVtID4+IDgpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZChudW0gJiAweGZmKTtcbiAgICB9XG4gICAgcGFja191aW50MzIobnVtKSB7XG4gICAgICAgIGNvbnN0IG4gPSBudW0gJiAweGZmZmZmZmZmO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgobiAmIDB4ZmYwMDAwMDApID4+PiAyNCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKChuICYgMHgwMGZmMDAwMCkgPj4+IDE2KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoKG4gJiAweDAwMDBmZjAwKSA+Pj4gOCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKG4gJiAweDAwMDAwMGZmKTtcbiAgICB9XG4gICAgcGFja191aW50NjQobnVtKSB7XG4gICAgICAgIGNvbnN0IGhpZ2ggPSBudW0gLyAyICoqIDMyO1xuICAgICAgICBjb25zdCBsb3cgPSBudW0gJSAyICoqIDMyO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgoaGlnaCAmIDB4ZmYwMDAwMDApID4+PiAyNCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKChoaWdoICYgMHgwMGZmMDAwMCkgPj4+IDE2KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoKGhpZ2ggJiAweDAwMDBmZjAwKSA+Pj4gOCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKGhpZ2ggJiAweDAwMDAwMGZmKTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoKGxvdyAmIDB4ZmYwMDAwMDApID4+PiAyNCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKChsb3cgJiAweDAwZmYwMDAwKSA+Pj4gMTYpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgobG93ICYgMHgwMDAwZmYwMCkgPj4+IDgpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZChsb3cgJiAweDAwMDAwMGZmKTtcbiAgICB9XG4gICAgcGFja19pbnQ4KG51bSkge1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZChudW0gJiAweGZmKTtcbiAgICB9XG4gICAgcGFja19pbnQxNihudW0pIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoKG51bSAmIDB4ZmYwMCkgPj4gOCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKG51bSAmIDB4ZmYpO1xuICAgIH1cbiAgICBwYWNrX2ludDMyKG51bSkge1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZChudW0gPj4+IDI0ICYgMHhmZik7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKChudW0gJiAweDAwZmYwMDAwKSA+Pj4gMTYpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgobnVtICYgMHgwMDAwZmYwMCkgPj4+IDgpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZChudW0gJiAweDAwMDAwMGZmKTtcbiAgICB9XG4gICAgcGFja19pbnQ2NChudW0pIHtcbiAgICAgICAgY29uc3QgaGlnaCA9IE1hdGguZmxvb3IobnVtIC8gMiAqKiAzMik7XG4gICAgICAgIGNvbnN0IGxvdyA9IG51bSAlIDIgKiogMzI7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKChoaWdoICYgMHhmZjAwMDAwMCkgPj4+IDI0KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoKGhpZ2ggJiAweDAwZmYwMDAwKSA+Pj4gMTYpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgoaGlnaCAmIDB4MDAwMGZmMDApID4+PiA4KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoaGlnaCAmIDB4MDAwMDAwZmYpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgobG93ICYgMHhmZjAwMDAwMCkgPj4+IDI0KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoKGxvdyAmIDB4MDBmZjAwMDApID4+PiAxNik7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKChsb3cgJiAweDAwMDBmZjAwKSA+Pj4gOCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKGxvdyAmIDB4MDAwMDAwZmYpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyID0gbmV3ICgwLCAkZTgzNzk4MTg2NTBlMjQ0MiRleHBvcnQkOTM2NTRkNGYyZDZjZDUyNCkoKTtcbiAgICAgICAgdGhpcy5fdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICB9XG59XG5cblxuZXhwb3J0IHskMGNmZDc4MjhhZDU5MTE1ZiRleHBvcnQkNDE3ODU3MDEwZGM5Mjg3ZiBhcyB1bnBhY2ssICQwY2ZkNzgyOGFkNTkxMTVmJGV4cG9ydCQyYTcwM2RiYjBjYjM1MzM5IGFzIHBhY2ssICQwY2ZkNzgyOGFkNTkxMTVmJGV4cG9ydCRiOWVjNGIxMTRhYTQwMDc0IGFzIFBhY2tlcn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5hcnlwYWNrLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/peerjs-js-binarypack/dist/binarypack.mjs\n");

/***/ })

};
;