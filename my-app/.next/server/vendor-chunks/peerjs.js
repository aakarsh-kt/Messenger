"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/peerjs";
exports.ids = ["vendor-chunks/peerjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/peerjs/dist/bundler.mjs":
/*!**********************************************!*\
  !*** ./node_modules/peerjs/dist/bundler.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseConnectionErrorType: () => (/* binding */ $78455e22dea96b8c$export$7974935686149686),\n/* harmony export */   BufferedConnection: () => (/* binding */ $a229bedbcaa6ca23$export$ff7c9d4c11d94e8b),\n/* harmony export */   ConnectionType: () => (/* binding */ $78455e22dea96b8c$export$3157d57b4135e3bc),\n/* harmony export */   DataConnectionErrorType: () => (/* binding */ $78455e22dea96b8c$export$49ae800c114df41d),\n/* harmony export */   MsgPack: () => (/* binding */ $6e39230ab36396ad$export$80f5de1a66c4d624),\n/* harmony export */   MsgPackPeer: () => (/* binding */ $1e0aff16be2c328e$export$d72c7bf8eef50853),\n/* harmony export */   Peer: () => (/* binding */ $416260bce337df90$export$ecd1fc136c422448),\n/* harmony export */   PeerError: () => (/* binding */ $23779d1881157a18$export$98871882f492de82),\n/* harmony export */   PeerErrorType: () => (/* binding */ $78455e22dea96b8c$export$9547aaa2e39030ff),\n/* harmony export */   SerializationType: () => (/* binding */ $78455e22dea96b8c$export$89f507cf986a947),\n/* harmony export */   ServerMessageType: () => (/* binding */ $78455e22dea96b8c$export$adb4a1754da6f10d),\n/* harmony export */   SocketEventType: () => (/* binding */ $78455e22dea96b8c$export$3b5c4a4b6354f023),\n/* harmony export */   StreamConnection: () => (/* binding */ $20dbe68149d7aad9$export$72aa44612e2200cd),\n/* harmony export */   \"default\": () => (/* binding */ $dd0187d7f28e386f$export$2e2bcd8739ae039),\n/* harmony export */   util: () => (/* binding */ $4f4134156c446392$export$7debb50ef11d5e0b)\n/* harmony export */ });\n/* harmony import */ var peerjs_js_binarypack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! peerjs-js-binarypack */ \"(ssr)/./node_modules/peerjs-js-binarypack/dist/binarypack.mjs\");\n/* harmony import */ var webrtc_adapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! webrtc-adapter */ \"(ssr)/./node_modules/webrtc-adapter/src/js/adapter_core.js\");\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @msgpack/msgpack */ \"(ssr)/./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\");\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @msgpack/msgpack */ \"(ssr)/./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs\");\n\n\n\n\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nclass $fcbcc7538a6776d5$export$f1c5f4c9cb95390b {\n    constructor(){\n        this.chunkedMTU = 16300 // The original 60000 bytes setting does not work when sending data from Firefox to Chrome, which is \"cut off\" after 16384 bytes and delivered individually.\n        ;\n        // Binary stuff\n        this._dataCount = 1;\n        this.chunk = (blob)=>{\n            const chunks = [];\n            const size = blob.byteLength;\n            const total = Math.ceil(size / this.chunkedMTU);\n            let index = 0;\n            let start = 0;\n            while(start < size){\n                const end = Math.min(size, start + this.chunkedMTU);\n                const b = blob.slice(start, end);\n                const chunk = {\n                    __peerData: this._dataCount,\n                    n: index,\n                    data: b,\n                    total: total\n                };\n                chunks.push(chunk);\n                start = end;\n                index++;\n            }\n            this._dataCount++;\n            return chunks;\n        };\n    }\n}\nfunction $fcbcc7538a6776d5$export$52c89ebcdc4f53f2(bufs) {\n    let size = 0;\n    for (const buf of bufs)size += buf.byteLength;\n    const result = new Uint8Array(size);\n    let offset = 0;\n    for (const buf of bufs){\n        result.set(buf, offset);\n        offset += buf.byteLength;\n    }\n    return result;\n}\n\n\n\n\nconst $fb63e766cfafaab9$var$webRTCAdapter = //@ts-ignore\n(0, webrtc_adapter__WEBPACK_IMPORTED_MODULE_1__[\"default\"]).default || (0, webrtc_adapter__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\nconst $fb63e766cfafaab9$export$25be9502477c137d = new class {\n    isWebRTCSupported() {\n        return typeof RTCPeerConnection !== \"undefined\";\n    }\n    isBrowserSupported() {\n        const browser = this.getBrowser();\n        const version = this.getVersion();\n        const validBrowser = this.supportedBrowsers.includes(browser);\n        if (!validBrowser) return false;\n        if (browser === \"chrome\") return version >= this.minChromeVersion;\n        if (browser === \"firefox\") return version >= this.minFirefoxVersion;\n        if (browser === \"safari\") return !this.isIOS && version >= this.minSafariVersion;\n        return false;\n    }\n    getBrowser() {\n        return $fb63e766cfafaab9$var$webRTCAdapter.browserDetails.browser;\n    }\n    getVersion() {\n        return $fb63e766cfafaab9$var$webRTCAdapter.browserDetails.version || 0;\n    }\n    isUnifiedPlanSupported() {\n        const browser = this.getBrowser();\n        const version = $fb63e766cfafaab9$var$webRTCAdapter.browserDetails.version || 0;\n        if (browser === \"chrome\" && version < this.minChromeVersion) return false;\n        if (browser === \"firefox\" && version >= this.minFirefoxVersion) return true;\n        if (!window.RTCRtpTransceiver || !(\"currentDirection\" in RTCRtpTransceiver.prototype)) return false;\n        let tempPc;\n        let supported = false;\n        try {\n            tempPc = new RTCPeerConnection();\n            tempPc.addTransceiver(\"audio\");\n            supported = true;\n        } catch (e) {} finally{\n            if (tempPc) tempPc.close();\n        }\n        return supported;\n    }\n    toString() {\n        return `Supports:\n    browser:${this.getBrowser()}\n    version:${this.getVersion()}\n    isIOS:${this.isIOS}\n    isWebRTCSupported:${this.isWebRTCSupported()}\n    isBrowserSupported:${this.isBrowserSupported()}\n    isUnifiedPlanSupported:${this.isUnifiedPlanSupported()}`;\n    }\n    constructor(){\n        this.isIOS = typeof navigator !== \"undefined\" ? [\n            \"iPad\",\n            \"iPhone\",\n            \"iPod\"\n        ].includes(navigator.platform) : false;\n        this.supportedBrowsers = [\n            \"firefox\",\n            \"chrome\",\n            \"safari\"\n        ];\n        this.minFirefoxVersion = 59;\n        this.minChromeVersion = 72;\n        this.minSafariVersion = 605;\n    }\n}();\n\n\nconst $9a84a32bf0bf36bb$export$f35f128fd59ea256 = (id)=>{\n    // Allow empty ids\n    return !id || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.test(id);\n};\n\n\nconst $0e5fd1585784c252$export$4e61f672936bec77 = ()=>Math.random().toString(36).slice(2);\n\n\nconst $4f4134156c446392$var$DEFAULT_CONFIG = {\n    iceServers: [\n        {\n            urls: \"stun:stun.l.google.com:19302\"\n        },\n        {\n            urls: [\n                \"turn:eu-0.turn.peerjs.com:3478\",\n                \"turn:us-0.turn.peerjs.com:3478\"\n            ],\n            username: \"peerjs\",\n            credential: \"peerjsp\"\n        }\n    ],\n    sdpSemantics: \"unified-plan\"\n};\nclass $4f4134156c446392$export$f8f26dd395d7e1bd extends (0, $fcbcc7538a6776d5$export$f1c5f4c9cb95390b) {\n    noop() {}\n    blobToArrayBuffer(blob, cb) {\n        const fr = new FileReader();\n        fr.onload = function(evt) {\n            if (evt.target) cb(evt.target.result);\n        };\n        fr.readAsArrayBuffer(blob);\n        return fr;\n    }\n    binaryStringToArrayBuffer(binary) {\n        const byteArray = new Uint8Array(binary.length);\n        for(let i = 0; i < binary.length; i++)byteArray[i] = binary.charCodeAt(i) & 0xff;\n        return byteArray.buffer;\n    }\n    isSecure() {\n        return location.protocol === \"https:\";\n    }\n    constructor(...args){\n        super(...args);\n        this.CLOUD_HOST = \"0.peerjs.com\";\n        this.CLOUD_PORT = 443;\n        // Browsers that need chunking:\n        this.chunkedBrowsers = {\n            Chrome: 1,\n            chrome: 1\n        };\n        // Returns browser-agnostic default config\n        this.defaultConfig = $4f4134156c446392$var$DEFAULT_CONFIG;\n        this.browser = (0, $fb63e766cfafaab9$export$25be9502477c137d).getBrowser();\n        this.browserVersion = (0, $fb63e766cfafaab9$export$25be9502477c137d).getVersion();\n        this.pack = peerjs_js_binarypack__WEBPACK_IMPORTED_MODULE_0__.pack;\n        this.unpack = peerjs_js_binarypack__WEBPACK_IMPORTED_MODULE_0__.unpack;\n        /**\n\t * A hash of WebRTC features mapped to booleans that correspond to whether the feature is supported by the current browser.\n\t *\n\t * :::caution\n\t * Only the properties documented here are guaranteed to be present on `util.supports`\n\t * :::\n\t */ this.supports = function() {\n            const supported = {\n                browser: (0, $fb63e766cfafaab9$export$25be9502477c137d).isBrowserSupported(),\n                webRTC: (0, $fb63e766cfafaab9$export$25be9502477c137d).isWebRTCSupported(),\n                audioVideo: false,\n                data: false,\n                binaryBlob: false,\n                reliable: false\n            };\n            if (!supported.webRTC) return supported;\n            let pc;\n            try {\n                pc = new RTCPeerConnection($4f4134156c446392$var$DEFAULT_CONFIG);\n                supported.audioVideo = true;\n                let dc;\n                try {\n                    dc = pc.createDataChannel(\"_PEERJSTEST\", {\n                        ordered: true\n                    });\n                    supported.data = true;\n                    supported.reliable = !!dc.ordered;\n                    // Binary test\n                    try {\n                        dc.binaryType = \"blob\";\n                        supported.binaryBlob = !(0, $fb63e766cfafaab9$export$25be9502477c137d).isIOS;\n                    } catch (e) {}\n                } catch (e) {} finally{\n                    if (dc) dc.close();\n                }\n            } catch (e) {} finally{\n                if (pc) pc.close();\n            }\n            return supported;\n        }();\n        // Ensure alphanumeric ids\n        this.validateId = (0, $9a84a32bf0bf36bb$export$f35f128fd59ea256);\n        this.randomToken = (0, $0e5fd1585784c252$export$4e61f672936bec77);\n    }\n}\nconst $4f4134156c446392$export$7debb50ef11d5e0b = new $4f4134156c446392$export$f8f26dd395d7e1bd();\n\n\n\nconst $257947e92926277a$var$LOG_PREFIX = \"PeerJS: \";\nvar $257947e92926277a$export$243e62d78d3b544d;\n(function(LogLevel) {\n    /**\n\t * Prints no logs.\n\t */ LogLevel[LogLevel[\"Disabled\"] = 0] = \"Disabled\";\n    /**\n\t * Prints only errors.\n\t */ LogLevel[LogLevel[\"Errors\"] = 1] = \"Errors\";\n    /**\n\t * Prints errors and warnings.\n\t */ LogLevel[LogLevel[\"Warnings\"] = 2] = \"Warnings\";\n    /**\n\t * Prints all logs.\n\t */ LogLevel[LogLevel[\"All\"] = 3] = \"All\";\n})($257947e92926277a$export$243e62d78d3b544d || ($257947e92926277a$export$243e62d78d3b544d = {}));\nclass $257947e92926277a$var$Logger {\n    get logLevel() {\n        return this._logLevel;\n    }\n    set logLevel(logLevel) {\n        this._logLevel = logLevel;\n    }\n    log(...args) {\n        if (this._logLevel >= 3) this._print(3, ...args);\n    }\n    warn(...args) {\n        if (this._logLevel >= 2) this._print(2, ...args);\n    }\n    error(...args) {\n        if (this._logLevel >= 1) this._print(1, ...args);\n    }\n    setLogFunction(fn) {\n        this._print = fn;\n    }\n    _print(logLevel, ...rest) {\n        const copy = [\n            $257947e92926277a$var$LOG_PREFIX,\n            ...rest\n        ];\n        for(const i in copy)if (copy[i] instanceof Error) copy[i] = \"(\" + copy[i].name + \") \" + copy[i].message;\n        if (logLevel >= 3) console.log(...copy);\n        else if (logLevel >= 2) console.warn(\"WARNING\", ...copy);\n        else if (logLevel >= 1) console.error(\"ERROR\", ...copy);\n    }\n    constructor(){\n        this._logLevel = 0;\n    }\n}\nvar $257947e92926277a$export$2e2bcd8739ae039 = new $257947e92926277a$var$Logger();\n\n\nvar $c4dcfd1d1ea86647$exports = {};\n\"use strict\";\nvar $c4dcfd1d1ea86647$var$has = Object.prototype.hasOwnProperty, $c4dcfd1d1ea86647$var$prefix = \"~\";\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */ function $c4dcfd1d1ea86647$var$Events() {}\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n    $c4dcfd1d1ea86647$var$Events.prototype = Object.create(null);\n    //\n    // This hack is needed because the `__proto__` property is still inherited in\n    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n    //\n    if (!new $c4dcfd1d1ea86647$var$Events().__proto__) $c4dcfd1d1ea86647$var$prefix = false;\n}\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */ function $c4dcfd1d1ea86647$var$EE(fn, context, once) {\n    this.fn = fn;\n    this.context = context;\n    this.once = once || false;\n}\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */ function $c4dcfd1d1ea86647$var$addListener(emitter, event, fn, context, once) {\n    if (typeof fn !== \"function\") throw new TypeError(\"The listener must be a function\");\n    var listener = new $c4dcfd1d1ea86647$var$EE(fn, context || emitter, once), evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event;\n    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n    else emitter._events[evt] = [\n        emitter._events[evt],\n        listener\n    ];\n    return emitter;\n}\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */ function $c4dcfd1d1ea86647$var$clearEvent(emitter, evt) {\n    if (--emitter._eventsCount === 0) emitter._events = new $c4dcfd1d1ea86647$var$Events();\n    else delete emitter._events[evt];\n}\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */ function $c4dcfd1d1ea86647$var$EventEmitter() {\n    this._events = new $c4dcfd1d1ea86647$var$Events();\n    this._eventsCount = 0;\n}\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.eventNames = function eventNames() {\n    var names = [], events, name;\n    if (this._eventsCount === 0) return names;\n    for(name in events = this._events)if ($c4dcfd1d1ea86647$var$has.call(events, name)) names.push($c4dcfd1d1ea86647$var$prefix ? name.slice(1) : name);\n    if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));\n    return names;\n};\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.listeners = function listeners(event) {\n    var evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event, handlers = this._events[evt];\n    if (!handlers) return [];\n    if (handlers.fn) return [\n        handlers.fn\n    ];\n    for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++)ee[i] = handlers[i].fn;\n    return ee;\n};\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.listenerCount = function listenerCount(event) {\n    var evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event, listeners = this._events[evt];\n    if (!listeners) return 0;\n    if (listeners.fn) return 1;\n    return listeners.length;\n};\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n    var evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event;\n    if (!this._events[evt]) return false;\n    var listeners = this._events[evt], len = arguments.length, args, i;\n    if (listeners.fn) {\n        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n        switch(len){\n            case 1:\n                return listeners.fn.call(listeners.context), true;\n            case 2:\n                return listeners.fn.call(listeners.context, a1), true;\n            case 3:\n                return listeners.fn.call(listeners.context, a1, a2), true;\n            case 4:\n                return listeners.fn.call(listeners.context, a1, a2, a3), true;\n            case 5:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n            case 6:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n        }\n        for(i = 1, args = new Array(len - 1); i < len; i++)args[i - 1] = arguments[i];\n        listeners.fn.apply(listeners.context, args);\n    } else {\n        var length = listeners.length, j;\n        for(i = 0; i < length; i++){\n            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n            switch(len){\n                case 1:\n                    listeners[i].fn.call(listeners[i].context);\n                    break;\n                case 2:\n                    listeners[i].fn.call(listeners[i].context, a1);\n                    break;\n                case 3:\n                    listeners[i].fn.call(listeners[i].context, a1, a2);\n                    break;\n                case 4:\n                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n                    break;\n                default:\n                    if (!args) for(j = 1, args = new Array(len - 1); j < len; j++)args[j - 1] = arguments[j];\n                    listeners[i].fn.apply(listeners[i].context, args);\n            }\n        }\n    }\n    return true;\n};\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.on = function on(event, fn, context) {\n    return $c4dcfd1d1ea86647$var$addListener(this, event, fn, context, false);\n};\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.once = function once(event, fn, context) {\n    return $c4dcfd1d1ea86647$var$addListener(this, event, fn, context, true);\n};\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n    var evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event;\n    if (!this._events[evt]) return this;\n    if (!fn) {\n        $c4dcfd1d1ea86647$var$clearEvent(this, evt);\n        return this;\n    }\n    var listeners = this._events[evt];\n    if (listeners.fn) {\n        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) $c4dcfd1d1ea86647$var$clearEvent(this, evt);\n    } else {\n        for(var i = 0, events = [], length = listeners.length; i < length; i++)if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) events.push(listeners[i]);\n        //\n        // Reset the array, or remove it completely if we have no more listeners.\n        //\n        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n        else $c4dcfd1d1ea86647$var$clearEvent(this, evt);\n    }\n    return this;\n};\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n    var evt;\n    if (event) {\n        evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event;\n        if (this._events[evt]) $c4dcfd1d1ea86647$var$clearEvent(this, evt);\n    } else {\n        this._events = new $c4dcfd1d1ea86647$var$Events();\n        this._eventsCount = 0;\n    }\n    return this;\n};\n//\n// Alias methods names because people roll like that.\n//\n$c4dcfd1d1ea86647$var$EventEmitter.prototype.off = $c4dcfd1d1ea86647$var$EventEmitter.prototype.removeListener;\n$c4dcfd1d1ea86647$var$EventEmitter.prototype.addListener = $c4dcfd1d1ea86647$var$EventEmitter.prototype.on;\n//\n// Expose the prefix.\n//\n$c4dcfd1d1ea86647$var$EventEmitter.prefixed = $c4dcfd1d1ea86647$var$prefix;\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\n$c4dcfd1d1ea86647$var$EventEmitter.EventEmitter = $c4dcfd1d1ea86647$var$EventEmitter;\n$c4dcfd1d1ea86647$exports = $c4dcfd1d1ea86647$var$EventEmitter;\n\n\n\nvar $78455e22dea96b8c$exports = {};\n\n$parcel$export($78455e22dea96b8c$exports, \"ConnectionType\", () => $78455e22dea96b8c$export$3157d57b4135e3bc);\n$parcel$export($78455e22dea96b8c$exports, \"PeerErrorType\", () => $78455e22dea96b8c$export$9547aaa2e39030ff);\n$parcel$export($78455e22dea96b8c$exports, \"BaseConnectionErrorType\", () => $78455e22dea96b8c$export$7974935686149686);\n$parcel$export($78455e22dea96b8c$exports, \"DataConnectionErrorType\", () => $78455e22dea96b8c$export$49ae800c114df41d);\n$parcel$export($78455e22dea96b8c$exports, \"SerializationType\", () => $78455e22dea96b8c$export$89f507cf986a947);\n$parcel$export($78455e22dea96b8c$exports, \"SocketEventType\", () => $78455e22dea96b8c$export$3b5c4a4b6354f023);\n$parcel$export($78455e22dea96b8c$exports, \"ServerMessageType\", () => $78455e22dea96b8c$export$adb4a1754da6f10d);\nvar $78455e22dea96b8c$export$3157d57b4135e3bc;\n(function(ConnectionType) {\n    ConnectionType[\"Data\"] = \"data\";\n    ConnectionType[\"Media\"] = \"media\";\n})($78455e22dea96b8c$export$3157d57b4135e3bc || ($78455e22dea96b8c$export$3157d57b4135e3bc = {}));\nvar $78455e22dea96b8c$export$9547aaa2e39030ff;\n(function(PeerErrorType) {\n    /**\n\t * The client's browser does not support some or all WebRTC features that you are trying to use.\n\t */ PeerErrorType[\"BrowserIncompatible\"] = \"browser-incompatible\";\n    /**\n\t * You've already disconnected this peer from the server and can no longer make any new connections on it.\n\t */ PeerErrorType[\"Disconnected\"] = \"disconnected\";\n    /**\n\t * The ID passed into the Peer constructor contains illegal characters.\n\t */ PeerErrorType[\"InvalidID\"] = \"invalid-id\";\n    /**\n\t * The API key passed into the Peer constructor contains illegal characters or is not in the system (cloud server only).\n\t */ PeerErrorType[\"InvalidKey\"] = \"invalid-key\";\n    /**\n\t * Lost or cannot establish a connection to the signalling server.\n\t */ PeerErrorType[\"Network\"] = \"network\";\n    /**\n\t * The peer you're trying to connect to does not exist.\n\t */ PeerErrorType[\"PeerUnavailable\"] = \"peer-unavailable\";\n    /**\n\t * PeerJS is being used securely, but the cloud server does not support SSL. Use a custom PeerServer.\n\t */ PeerErrorType[\"SslUnavailable\"] = \"ssl-unavailable\";\n    /**\n\t * Unable to reach the server.\n\t */ PeerErrorType[\"ServerError\"] = \"server-error\";\n    /**\n\t * An error from the underlying socket.\n\t */ PeerErrorType[\"SocketError\"] = \"socket-error\";\n    /**\n\t * The underlying socket closed unexpectedly.\n\t */ PeerErrorType[\"SocketClosed\"] = \"socket-closed\";\n    /**\n\t * The ID passed into the Peer constructor is already taken.\n\t *\n\t * :::caution\n\t * This error is not fatal if your peer has open peer-to-peer connections.\n\t * This can happen if you attempt to {@apilink Peer.reconnect} a peer that has been disconnected from the server,\n\t * but its old ID has now been taken.\n\t * :::\n\t */ PeerErrorType[\"UnavailableID\"] = \"unavailable-id\";\n    /**\n\t * Native WebRTC errors.\n\t */ PeerErrorType[\"WebRTC\"] = \"webrtc\";\n})($78455e22dea96b8c$export$9547aaa2e39030ff || ($78455e22dea96b8c$export$9547aaa2e39030ff = {}));\nvar $78455e22dea96b8c$export$7974935686149686;\n(function(BaseConnectionErrorType) {\n    BaseConnectionErrorType[\"NegotiationFailed\"] = \"negotiation-failed\";\n    BaseConnectionErrorType[\"ConnectionClosed\"] = \"connection-closed\";\n})($78455e22dea96b8c$export$7974935686149686 || ($78455e22dea96b8c$export$7974935686149686 = {}));\nvar $78455e22dea96b8c$export$49ae800c114df41d;\n(function(DataConnectionErrorType) {\n    DataConnectionErrorType[\"NotOpenYet\"] = \"not-open-yet\";\n    DataConnectionErrorType[\"MessageToBig\"] = \"message-too-big\";\n})($78455e22dea96b8c$export$49ae800c114df41d || ($78455e22dea96b8c$export$49ae800c114df41d = {}));\nvar $78455e22dea96b8c$export$89f507cf986a947;\n(function(SerializationType) {\n    SerializationType[\"Binary\"] = \"binary\";\n    SerializationType[\"BinaryUTF8\"] = \"binary-utf8\";\n    SerializationType[\"JSON\"] = \"json\";\n    SerializationType[\"None\"] = \"raw\";\n})($78455e22dea96b8c$export$89f507cf986a947 || ($78455e22dea96b8c$export$89f507cf986a947 = {}));\nvar $78455e22dea96b8c$export$3b5c4a4b6354f023;\n(function(SocketEventType) {\n    SocketEventType[\"Message\"] = \"message\";\n    SocketEventType[\"Disconnected\"] = \"disconnected\";\n    SocketEventType[\"Error\"] = \"error\";\n    SocketEventType[\"Close\"] = \"close\";\n})($78455e22dea96b8c$export$3b5c4a4b6354f023 || ($78455e22dea96b8c$export$3b5c4a4b6354f023 = {}));\nvar $78455e22dea96b8c$export$adb4a1754da6f10d;\n(function(ServerMessageType) {\n    ServerMessageType[\"Heartbeat\"] = \"HEARTBEAT\";\n    ServerMessageType[\"Candidate\"] = \"CANDIDATE\";\n    ServerMessageType[\"Offer\"] = \"OFFER\";\n    ServerMessageType[\"Answer\"] = \"ANSWER\";\n    ServerMessageType[\"Open\"] = \"OPEN\";\n    ServerMessageType[\"Error\"] = \"ERROR\";\n    ServerMessageType[\"IdTaken\"] = \"ID-TAKEN\";\n    ServerMessageType[\"InvalidKey\"] = \"INVALID-KEY\";\n    ServerMessageType[\"Leave\"] = \"LEAVE\";\n    ServerMessageType[\"Expire\"] = \"EXPIRE\";\n})($78455e22dea96b8c$export$adb4a1754da6f10d || ($78455e22dea96b8c$export$adb4a1754da6f10d = {}));\n\n\nvar $f5f881ec4575f1fc$exports = {};\n$f5f881ec4575f1fc$exports = JSON.parse('{\"name\":\"peerjs\",\"version\":\"1.5.4\",\"keywords\":[\"peerjs\",\"webrtc\",\"p2p\",\"rtc\"],\"description\":\"PeerJS client\",\"homepage\":\"https://peerjs.com\",\"bugs\":{\"url\":\"https://github.com/peers/peerjs/issues\"},\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/peers/peerjs\"},\"license\":\"MIT\",\"contributors\":[\"Michelle Bu <michelle@michellebu.com>\",\"afrokick <devbyru@gmail.com>\",\"ericz <really.ez@gmail.com>\",\"Jairo <kidandcat@gmail.com>\",\"Jonas Gloning <34194370+jonasgloning@users.noreply.github.com>\",\"Jairo Caro-Accino Viciana <jairo@galax.be>\",\"Carlos Caballero <carlos.caballero.gonzalez@gmail.com>\",\"hc <hheennrryy@gmail.com>\",\"Muhammad Asif <capripio@gmail.com>\",\"PrashoonB <prashoonbhattacharjee@gmail.com>\",\"Harsh Bardhan Mishra <47351025+HarshCasper@users.noreply.github.com>\",\"akotynski <aleksanderkotbury@gmail.com>\",\"lmb <i@lmb.io>\",\"Jairooo <jairocaro@msn.com>\",\"Moritz St\\xfcckler <moritz.stueckler@gmail.com>\",\"Simon <crydotsnakegithub@gmail.com>\",\"Denis Lukov <denismassters@gmail.com>\",\"Philipp Hancke <fippo@andyet.net>\",\"Hans Oksendahl <hansoksendahl@gmail.com>\",\"Jess <jessachandler@gmail.com>\",\"khankuan <khankuan@gmail.com>\",\"DUODVK <kurmanov.work@gmail.com>\",\"XiZhao <kwang1imsa@gmail.com>\",\"Matthias Lohr <matthias@lohr.me>\",\"=frank tree <=frnktrb@googlemail.com>\",\"Andre Eckardt <aeckardt@outlook.com>\",\"Chris Cowan <agentme49@gmail.com>\",\"Alex Chuev <alex@chuev.com>\",\"alxnull <alxnull@e.mail.de>\",\"Yemel Jardi <angel.jardi@gmail.com>\",\"Ben Parnell <benjaminparnell.94@gmail.com>\",\"Benny Lichtner <bennlich@gmail.com>\",\"fresheneesz <bitetrudpublic@gmail.com>\",\"bob.barstead@exaptive.com <bob.barstead@exaptive.com>\",\"chandika <chandika@gmail.com>\",\"emersion <contact@emersion.fr>\",\"Christopher Van <cvan@users.noreply.github.com>\",\"eddieherm <edhermoso@gmail.com>\",\"Eduardo Pinho <enet4mikeenet@gmail.com>\",\"Evandro Zanatta <ezanatta@tray.net.br>\",\"Gardner Bickford <gardner@users.noreply.github.com>\",\"Gian Luca <gianluca.cecchi@cynny.com>\",\"PatrickJS <github@gdi2290.com>\",\"jonnyf <github@jonathanfoss.co.uk>\",\"Hizkia Felix <hizkifw@gmail.com>\",\"Hristo Oskov <hristo.oskov@gmail.com>\",\"Isaac Madwed <i.madwed@gmail.com>\",\"Ilya Konanykhin <ilya.konanykhin@gmail.com>\",\"jasonbarry <jasbarry@me.com>\",\"Jonathan Burke <jonathan.burke.1311@googlemail.com>\",\"Josh Hamit <josh.hamit@gmail.com>\",\"Jordan Austin <jrax86@gmail.com>\",\"Joel Wetzell <jwetzell@yahoo.com>\",\"xizhao <kevin.wang@cloudera.com>\",\"Alberto Torres <kungfoobar@gmail.com>\",\"Jonathan Mayol <mayoljonathan@gmail.com>\",\"Jefferson Felix <me@jsfelix.dev>\",\"Rolf Erik Lekang <me@rolflekang.com>\",\"Kevin Mai-Husan Chia <mhchia@users.noreply.github.com>\",\"Pepijn de Vos <pepijndevos@gmail.com>\",\"JooYoung <qkdlql@naver.com>\",\"Tobias Speicher <rootcommander@gmail.com>\",\"Steve Blaurock <sblaurock@gmail.com>\",\"Kyrylo Shegeda <shegeda@ualberta.ca>\",\"Diwank Singh Tomer <singh@diwank.name>\",\"So\\u0308ren Balko <Soeren.Balko@gmail.com>\",\"Arpit Solanki <solankiarpit1997@gmail.com>\",\"Yuki Ito <yuki@gnnk.net>\",\"Artur Zayats <zag2art@gmail.com>\"],\"funding\":{\"type\":\"opencollective\",\"url\":\"https://opencollective.com/peer\"},\"collective\":{\"type\":\"opencollective\",\"url\":\"https://opencollective.com/peer\"},\"files\":[\"dist/*\"],\"sideEffects\":[\"lib/global.ts\",\"lib/supports.ts\"],\"main\":\"dist/bundler.cjs\",\"module\":\"dist/bundler.mjs\",\"browser-minified\":\"dist/peerjs.min.js\",\"browser-unminified\":\"dist/peerjs.js\",\"browser-minified-msgpack\":\"dist/serializer.msgpack.mjs\",\"types\":\"dist/types.d.ts\",\"engines\":{\"node\":\">= 14\"},\"targets\":{\"types\":{\"source\":\"lib/exports.ts\"},\"main\":{\"source\":\"lib/exports.ts\",\"sourceMap\":{\"inlineSources\":true}},\"module\":{\"source\":\"lib/exports.ts\",\"includeNodeModules\":[\"eventemitter3\"],\"sourceMap\":{\"inlineSources\":true}},\"browser-minified\":{\"context\":\"browser\",\"outputFormat\":\"global\",\"optimize\":true,\"engines\":{\"browsers\":\"chrome >= 83, edge >= 83, firefox >= 80, safari >= 15\"},\"source\":\"lib/global.ts\"},\"browser-unminified\":{\"context\":\"browser\",\"outputFormat\":\"global\",\"optimize\":false,\"engines\":{\"browsers\":\"chrome >= 83, edge >= 83, firefox >= 80, safari >= 15\"},\"source\":\"lib/global.ts\"},\"browser-minified-msgpack\":{\"context\":\"browser\",\"outputFormat\":\"esmodule\",\"isLibrary\":true,\"optimize\":true,\"engines\":{\"browsers\":\"chrome >= 83, edge >= 83, firefox >= 102, safari >= 15\"},\"source\":\"lib/dataconnection/StreamConnection/MsgPack.ts\"}},\"scripts\":{\"contributors\":\"git-authors-cli --print=false && prettier --write package.json && git add package.json package-lock.json && git commit -m \\\\\"chore(contributors): update and sort contributors list\\\\\"\",\"check\":\"tsc --noEmit && tsc -p e2e/tsconfig.json --noEmit\",\"watch\":\"parcel watch\",\"build\":\"rm -rf dist && parcel build\",\"prepublishOnly\":\"npm run build\",\"test\":\"jest\",\"test:watch\":\"jest --watch\",\"coverage\":\"jest --coverage --collectCoverageFrom=\\\\\"./lib/**\\\\\"\",\"format\":\"prettier --write .\",\"format:check\":\"prettier --check .\",\"semantic-release\":\"semantic-release\",\"e2e\":\"wdio run e2e/wdio.local.conf.ts\",\"e2e:bstack\":\"wdio run e2e/wdio.bstack.conf.ts\"},\"devDependencies\":{\"@parcel/config-default\":\"^2.9.3\",\"@parcel/packager-ts\":\"^2.9.3\",\"@parcel/transformer-typescript-tsc\":\"^2.9.3\",\"@parcel/transformer-typescript-types\":\"^2.9.3\",\"@semantic-release/changelog\":\"^6.0.1\",\"@semantic-release/git\":\"^10.0.1\",\"@swc/core\":\"^1.3.27\",\"@swc/jest\":\"^0.2.24\",\"@types/jasmine\":\"^4.3.4\",\"@wdio/browserstack-service\":\"^8.11.2\",\"@wdio/cli\":\"^8.11.2\",\"@wdio/globals\":\"^8.11.2\",\"@wdio/jasmine-framework\":\"^8.11.2\",\"@wdio/local-runner\":\"^8.11.2\",\"@wdio/spec-reporter\":\"^8.11.2\",\"@wdio/types\":\"^8.10.4\",\"http-server\":\"^14.1.1\",\"jest\":\"^29.3.1\",\"jest-environment-jsdom\":\"^29.3.1\",\"mock-socket\":\"^9.0.0\",\"parcel\":\"^2.9.3\",\"prettier\":\"^3.0.0\",\"semantic-release\":\"^21.0.0\",\"ts-node\":\"^10.9.1\",\"typescript\":\"^5.0.0\",\"wdio-geckodriver-service\":\"^5.0.1\"},\"dependencies\":{\"@msgpack/msgpack\":\"^2.8.0\",\"eventemitter3\":\"^4.0.7\",\"peerjs-js-binarypack\":\"^2.1.0\",\"webrtc-adapter\":\"^9.0.0\"},\"alias\":{\"process\":false,\"buffer\":false}}');\n\n\nclass $8f5bfa60836d261d$export$4798917dbf149b79 extends (0, $c4dcfd1d1ea86647$exports.EventEmitter) {\n    constructor(secure, host, port, path, key, pingInterval = 5000){\n        super();\n        this.pingInterval = pingInterval;\n        this._disconnected = true;\n        this._messagesQueue = [];\n        const wsProtocol = secure ? \"wss://\" : \"ws://\";\n        this._baseUrl = wsProtocol + host + \":\" + port + path + \"peerjs?key=\" + key;\n    }\n    start(id, token) {\n        this._id = id;\n        const wsUrl = `${this._baseUrl}&id=${id}&token=${token}`;\n        if (!!this._socket || !this._disconnected) return;\n        this._socket = new WebSocket(wsUrl + \"&version=\" + (0, $f5f881ec4575f1fc$exports.version));\n        this._disconnected = false;\n        this._socket.onmessage = (event)=>{\n            let data;\n            try {\n                data = JSON.parse(event.data);\n                (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Server message received:\", data);\n            } catch (e) {\n                (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Invalid server message\", event.data);\n                return;\n            }\n            this.emit((0, $78455e22dea96b8c$export$3b5c4a4b6354f023).Message, data);\n        };\n        this._socket.onclose = (event)=>{\n            if (this._disconnected) return;\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Socket closed.\", event);\n            this._cleanup();\n            this._disconnected = true;\n            this.emit((0, $78455e22dea96b8c$export$3b5c4a4b6354f023).Disconnected);\n        };\n        // Take care of the queue of connections if necessary and make sure Peer knows\n        // socket is open.\n        this._socket.onopen = ()=>{\n            if (this._disconnected) return;\n            this._sendQueuedMessages();\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Socket open\");\n            this._scheduleHeartbeat();\n        };\n    }\n    _scheduleHeartbeat() {\n        this._wsPingTimer = setTimeout(()=>{\n            this._sendHeartbeat();\n        }, this.pingInterval);\n    }\n    _sendHeartbeat() {\n        if (!this._wsOpen()) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Cannot send heartbeat, because socket closed`);\n            return;\n        }\n        const message = JSON.stringify({\n            type: (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Heartbeat\n        });\n        this._socket.send(message);\n        this._scheduleHeartbeat();\n    }\n    /** Is the websocket currently open? */ _wsOpen() {\n        return !!this._socket && this._socket.readyState === 1;\n    }\n    /** Send queued messages. */ _sendQueuedMessages() {\n        //Create copy of queue and clear it,\n        //because send method push the message back to queue if smth will go wrong\n        const copiedQueue = [\n            ...this._messagesQueue\n        ];\n        this._messagesQueue = [];\n        for (const message of copiedQueue)this.send(message);\n    }\n    /** Exposed send for DC & Peer. */ send(data) {\n        if (this._disconnected) return;\n        // If we didn't get an ID yet, we can't yet send anything so we should queue\n        // up these messages.\n        if (!this._id) {\n            this._messagesQueue.push(data);\n            return;\n        }\n        if (!data.type) {\n            this.emit((0, $78455e22dea96b8c$export$3b5c4a4b6354f023).Error, \"Invalid message\");\n            return;\n        }\n        if (!this._wsOpen()) return;\n        const message = JSON.stringify(data);\n        this._socket.send(message);\n    }\n    close() {\n        if (this._disconnected) return;\n        this._cleanup();\n        this._disconnected = true;\n    }\n    _cleanup() {\n        if (this._socket) {\n            this._socket.onopen = this._socket.onmessage = this._socket.onclose = null;\n            this._socket.close();\n            this._socket = undefined;\n        }\n        clearTimeout(this._wsPingTimer);\n    }\n}\n\n\n\n\n\n\nclass $b82fb8fc0514bfc1$export$89e6bb5ad64bf4a {\n    constructor(connection){\n        this.connection = connection;\n    }\n    /** Returns a PeerConnection object set up correctly (for data, media). */ startConnection(options) {\n        const peerConnection = this._startPeerConnection();\n        // Set the connection's PC.\n        this.connection.peerConnection = peerConnection;\n        if (this.connection.type === (0, $78455e22dea96b8c$export$3157d57b4135e3bc).Media && options._stream) this._addTracksToConnection(options._stream, peerConnection);\n        // What do we need to do now?\n        if (options.originator) {\n            const dataConnection = this.connection;\n            const config = {\n                ordered: !!options.reliable\n            };\n            const dataChannel = peerConnection.createDataChannel(dataConnection.label, config);\n            dataConnection._initializeDataChannel(dataChannel);\n            this._makeOffer();\n        } else this.handleSDP(\"OFFER\", options.sdp);\n    }\n    /** Start a PC. */ _startPeerConnection() {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Creating RTCPeerConnection.\");\n        const peerConnection = new RTCPeerConnection(this.connection.provider.options.config);\n        this._setupListeners(peerConnection);\n        return peerConnection;\n    }\n    /** Set up various WebRTC listeners. */ _setupListeners(peerConnection) {\n        const peerId = this.connection.peer;\n        const connectionId = this.connection.connectionId;\n        const connectionType = this.connection.type;\n        const provider = this.connection.provider;\n        // ICE CANDIDATES.\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Listening for ICE candidates.\");\n        peerConnection.onicecandidate = (evt)=>{\n            if (!evt.candidate || !evt.candidate.candidate) return;\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Received ICE candidates for ${peerId}:`, evt.candidate);\n            provider.socket.send({\n                type: (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Candidate,\n                payload: {\n                    candidate: evt.candidate,\n                    type: connectionType,\n                    connectionId: connectionId\n                },\n                dst: peerId\n            });\n        };\n        peerConnection.oniceconnectionstatechange = ()=>{\n            switch(peerConnection.iceConnectionState){\n                case \"failed\":\n                    (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"iceConnectionState is failed, closing connections to \" + peerId);\n                    this.connection.emitError((0, $78455e22dea96b8c$export$7974935686149686).NegotiationFailed, \"Negotiation of connection to \" + peerId + \" failed.\");\n                    this.connection.close();\n                    break;\n                case \"closed\":\n                    (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"iceConnectionState is closed, closing connections to \" + peerId);\n                    this.connection.emitError((0, $78455e22dea96b8c$export$7974935686149686).ConnectionClosed, \"Connection to \" + peerId + \" closed.\");\n                    this.connection.close();\n                    break;\n                case \"disconnected\":\n                    (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"iceConnectionState changed to disconnected on the connection with \" + peerId);\n                    break;\n                case \"completed\":\n                    peerConnection.onicecandidate = ()=>{};\n                    break;\n            }\n            this.connection.emit(\"iceStateChanged\", peerConnection.iceConnectionState);\n        };\n        // DATACONNECTION.\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Listening for data channel\");\n        // Fired between offer and answer, so options should already be saved\n        // in the options hash.\n        peerConnection.ondatachannel = (evt)=>{\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Received data channel\");\n            const dataChannel = evt.channel;\n            const connection = provider.getConnection(peerId, connectionId);\n            connection._initializeDataChannel(dataChannel);\n        };\n        // MEDIACONNECTION.\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Listening for remote stream\");\n        peerConnection.ontrack = (evt)=>{\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Received remote stream\");\n            const stream = evt.streams[0];\n            const connection = provider.getConnection(peerId, connectionId);\n            if (connection.type === (0, $78455e22dea96b8c$export$3157d57b4135e3bc).Media) {\n                const mediaConnection = connection;\n                this._addStreamToMediaConnection(stream, mediaConnection);\n            }\n        };\n    }\n    cleanup() {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Cleaning up PeerConnection to \" + this.connection.peer);\n        const peerConnection = this.connection.peerConnection;\n        if (!peerConnection) return;\n        this.connection.peerConnection = null;\n        //unsubscribe from all PeerConnection's events\n        peerConnection.onicecandidate = peerConnection.oniceconnectionstatechange = peerConnection.ondatachannel = peerConnection.ontrack = ()=>{};\n        const peerConnectionNotClosed = peerConnection.signalingState !== \"closed\";\n        let dataChannelNotClosed = false;\n        const dataChannel = this.connection.dataChannel;\n        if (dataChannel) dataChannelNotClosed = !!dataChannel.readyState && dataChannel.readyState !== \"closed\";\n        if (peerConnectionNotClosed || dataChannelNotClosed) peerConnection.close();\n    }\n    async _makeOffer() {\n        const peerConnection = this.connection.peerConnection;\n        const provider = this.connection.provider;\n        try {\n            const offer = await peerConnection.createOffer(this.connection.options.constraints);\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Created offer.\");\n            if (this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform === \"function\") offer.sdp = this.connection.options.sdpTransform(offer.sdp) || offer.sdp;\n            try {\n                await peerConnection.setLocalDescription(offer);\n                (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Set localDescription:\", offer, `for:${this.connection.peer}`);\n                let payload = {\n                    sdp: offer,\n                    type: this.connection.type,\n                    connectionId: this.connection.connectionId,\n                    metadata: this.connection.metadata\n                };\n                if (this.connection.type === (0, $78455e22dea96b8c$export$3157d57b4135e3bc).Data) {\n                    const dataConnection = this.connection;\n                    payload = {\n                        ...payload,\n                        label: dataConnection.label,\n                        reliable: dataConnection.reliable,\n                        serialization: dataConnection.serialization\n                    };\n                }\n                provider.socket.send({\n                    type: (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Offer,\n                    payload: payload,\n                    dst: this.connection.peer\n                });\n            } catch (err) {\n                // TODO: investigate why _makeOffer is being called from the answer\n                if (err != \"OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer\") {\n                    provider.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).WebRTC, err);\n                    (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Failed to setLocalDescription, \", err);\n                }\n            }\n        } catch (err_1) {\n            provider.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).WebRTC, err_1);\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Failed to createOffer, \", err_1);\n        }\n    }\n    async _makeAnswer() {\n        const peerConnection = this.connection.peerConnection;\n        const provider = this.connection.provider;\n        try {\n            const answer = await peerConnection.createAnswer();\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Created answer.\");\n            if (this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform === \"function\") answer.sdp = this.connection.options.sdpTransform(answer.sdp) || answer.sdp;\n            try {\n                await peerConnection.setLocalDescription(answer);\n                (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Set localDescription:`, answer, `for:${this.connection.peer}`);\n                provider.socket.send({\n                    type: (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Answer,\n                    payload: {\n                        sdp: answer,\n                        type: this.connection.type,\n                        connectionId: this.connection.connectionId\n                    },\n                    dst: this.connection.peer\n                });\n            } catch (err) {\n                provider.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).WebRTC, err);\n                (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Failed to setLocalDescription, \", err);\n            }\n        } catch (err_1) {\n            provider.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).WebRTC, err_1);\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Failed to create answer, \", err_1);\n        }\n    }\n    /** Handle an SDP. */ async handleSDP(type, sdp) {\n        sdp = new RTCSessionDescription(sdp);\n        const peerConnection = this.connection.peerConnection;\n        const provider = this.connection.provider;\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Setting remote description\", sdp);\n        const self = this;\n        try {\n            await peerConnection.setRemoteDescription(sdp);\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Set remoteDescription:${type} for:${this.connection.peer}`);\n            if (type === \"OFFER\") await self._makeAnswer();\n        } catch (err) {\n            provider.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).WebRTC, err);\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Failed to setRemoteDescription, \", err);\n        }\n    }\n    /** Handle a candidate. */ async handleCandidate(ice) {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(`handleCandidate:`, ice);\n        try {\n            await this.connection.peerConnection.addIceCandidate(ice);\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Added ICE candidate for:${this.connection.peer}`);\n        } catch (err) {\n            this.connection.provider.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).WebRTC, err);\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Failed to handleCandidate, \", err);\n        }\n    }\n    _addTracksToConnection(stream, peerConnection) {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(`add tracks from stream ${stream.id} to peer connection`);\n        if (!peerConnection.addTrack) return (0, $257947e92926277a$export$2e2bcd8739ae039).error(`Your browser does't support RTCPeerConnection#addTrack. Ignored.`);\n        stream.getTracks().forEach((track)=>{\n            peerConnection.addTrack(track, stream);\n        });\n    }\n    _addStreamToMediaConnection(stream, mediaConnection) {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(`add stream ${stream.id} to media connection ${mediaConnection.connectionId}`);\n        mediaConnection.addStream(stream);\n    }\n}\n\n\n\n\n\nclass $23779d1881157a18$export$6a678e589c8a4542 extends (0, $c4dcfd1d1ea86647$exports.EventEmitter) {\n    /**\n\t * Emits a typed error message.\n\t *\n\t * @internal\n\t */ emitError(type, err) {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).error(\"Error:\", err);\n        // @ts-ignore\n        this.emit(\"error\", new $23779d1881157a18$export$98871882f492de82(`${type}`, err));\n    }\n}\nclass $23779d1881157a18$export$98871882f492de82 extends Error {\n    /**\n\t * @internal\n\t */ constructor(type, err){\n        if (typeof err === \"string\") super(err);\n        else {\n            super();\n            Object.assign(this, err);\n        }\n        this.type = type;\n    }\n}\n\n\nclass $5045192fc6d387ba$export$23a2a68283c24d80 extends (0, $23779d1881157a18$export$6a678e589c8a4542) {\n    /**\n\t * Whether the media connection is active (e.g. your call has been answered).\n\t * You can check this if you want to set a maximum wait time for a one-sided call.\n\t */ get open() {\n        return this._open;\n    }\n    constructor(/**\n\t\t * The ID of the peer on the other end of this connection.\n\t\t */ peer, provider, options){\n        super();\n        this.peer = peer;\n        this.provider = provider;\n        this.options = options;\n        this._open = false;\n        this.metadata = options.metadata;\n    }\n}\n\n\nclass $5c1d08c7c57da9a3$export$4a84e95a2324ac29 extends (0, $5045192fc6d387ba$export$23a2a68283c24d80) {\n    static #_ = this.ID_PREFIX = \"mc_\";\n    /**\n\t * For media connections, this is always 'media'.\n\t */ get type() {\n        return (0, $78455e22dea96b8c$export$3157d57b4135e3bc).Media;\n    }\n    get localStream() {\n        return this._localStream;\n    }\n    get remoteStream() {\n        return this._remoteStream;\n    }\n    constructor(peerId, provider, options){\n        super(peerId, provider, options);\n        this._localStream = this.options._stream;\n        this.connectionId = this.options.connectionId || $5c1d08c7c57da9a3$export$4a84e95a2324ac29.ID_PREFIX + (0, $4f4134156c446392$export$7debb50ef11d5e0b).randomToken();\n        this._negotiator = new (0, $b82fb8fc0514bfc1$export$89e6bb5ad64bf4a)(this);\n        if (this._localStream) this._negotiator.startConnection({\n            _stream: this._localStream,\n            originator: true\n        });\n    }\n    /** Called by the Negotiator when the DataChannel is ready. */ _initializeDataChannel(dc) {\n        this.dataChannel = dc;\n        this.dataChannel.onopen = ()=>{\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc connection success`);\n            this.emit(\"willCloseOnRemote\");\n        };\n        this.dataChannel.onclose = ()=>{\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc closed for:`, this.peer);\n            this.close();\n        };\n    }\n    addStream(remoteStream) {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Receiving stream\", remoteStream);\n        this._remoteStream = remoteStream;\n        super.emit(\"stream\", remoteStream); // Should we call this `open`?\n    }\n    /**\n\t * @internal\n\t */ handleMessage(message) {\n        const type = message.type;\n        const payload = message.payload;\n        switch(message.type){\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Answer:\n                // Forward to negotiator\n                this._negotiator.handleSDP(type, payload.sdp);\n                this._open = true;\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Candidate:\n                this._negotiator.handleCandidate(payload.candidate);\n                break;\n            default:\n                (0, $257947e92926277a$export$2e2bcd8739ae039).warn(`Unrecognized message type:${type} from peer:${this.peer}`);\n                break;\n        }\n    }\n    /**\n     * When receiving a {@apilink PeerEvents | `call`} event on a peer, you can call\n     * `answer` on the media connection provided by the callback to accept the call\n     * and optionally send your own media stream.\n\n     *\n     * @param stream A WebRTC media stream.\n     * @param options\n     * @returns\n     */ answer(stream, options = {}) {\n        if (this._localStream) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).warn(\"Local stream already exists on this MediaConnection. Are you answering a call twice?\");\n            return;\n        }\n        this._localStream = stream;\n        if (options && options.sdpTransform) this.options.sdpTransform = options.sdpTransform;\n        this._negotiator.startConnection({\n            ...this.options._payload,\n            _stream: stream\n        });\n        // Retrieve lost messages stored because PeerConnection not set up.\n        const messages = this.provider._getMessages(this.connectionId);\n        for (const message of messages)this.handleMessage(message);\n        this._open = true;\n    }\n    /**\n\t * Exposed functionality for users.\n\t */ /**\n\t * Closes the media connection.\n\t */ close() {\n        if (this._negotiator) {\n            this._negotiator.cleanup();\n            this._negotiator = null;\n        }\n        this._localStream = null;\n        this._remoteStream = null;\n        if (this.provider) {\n            this.provider._removeConnection(this);\n            this.provider = null;\n        }\n        if (this.options && this.options._stream) this.options._stream = null;\n        if (!this.open) return;\n        this._open = false;\n        super.emit(\"close\");\n    }\n}\n\n\n\n\n\n\nclass $abf266641927cd89$export$2c4e825dc9120f87 {\n    constructor(_options){\n        this._options = _options;\n    }\n    _buildRequest(method) {\n        const protocol = this._options.secure ? \"https\" : \"http\";\n        const { host: host, port: port, path: path, key: key } = this._options;\n        const url = new URL(`${protocol}://${host}:${port}${path}${key}/${method}`);\n        // TODO: Why timestamp, why random?\n        url.searchParams.set(\"ts\", `${Date.now()}${Math.random()}`);\n        url.searchParams.set(\"version\", (0, $f5f881ec4575f1fc$exports.version));\n        return fetch(url.href, {\n            referrerPolicy: this._options.referrerPolicy\n        });\n    }\n    /** Get a unique ID from the server via XHR and initialize with it. */ async retrieveId() {\n        try {\n            const response = await this._buildRequest(\"id\");\n            if (response.status !== 200) throw new Error(`Error. Status:${response.status}`);\n            return response.text();\n        } catch (error) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).error(\"Error retrieving ID\", error);\n            let pathError = \"\";\n            if (this._options.path === \"/\" && this._options.host !== (0, $4f4134156c446392$export$7debb50ef11d5e0b).CLOUD_HOST) pathError = \" If you passed in a `path` to your self-hosted PeerServer, you'll also need to pass in that same path when creating a new Peer.\";\n            throw new Error(\"Could not get an ID from the server.\" + pathError);\n        }\n    }\n    /** @deprecated */ async listAllPeers() {\n        try {\n            const response = await this._buildRequest(\"peers\");\n            if (response.status !== 200) {\n                if (response.status === 401) {\n                    let helpfulError = \"\";\n                    if (this._options.host === (0, $4f4134156c446392$export$7debb50ef11d5e0b).CLOUD_HOST) helpfulError = \"It looks like you're using the cloud server. You can email team@peerjs.com to enable peer listing for your API key.\";\n                    else helpfulError = \"You need to enable `allow_discovery` on your self-hosted PeerServer to use this feature.\";\n                    throw new Error(\"It doesn't look like you have permission to list peers IDs. \" + helpfulError);\n                }\n                throw new Error(`Error. Status:${response.status}`);\n            }\n            return response.json();\n        } catch (error) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).error(\"Error retrieving list peers\", error);\n            throw new Error(\"Could not get list peers from the server.\" + error);\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\nclass $6366c4ca161bc297$export$d365f7ad9d7df9c9 extends (0, $5045192fc6d387ba$export$23a2a68283c24d80) {\n    static #_ = this.ID_PREFIX = \"dc_\";\n    static #_2 = this.MAX_BUFFERED_AMOUNT = 8388608;\n    get type() {\n        return (0, $78455e22dea96b8c$export$3157d57b4135e3bc).Data;\n    }\n    constructor(peerId, provider, options){\n        super(peerId, provider, options);\n        this.connectionId = this.options.connectionId || $6366c4ca161bc297$export$d365f7ad9d7df9c9.ID_PREFIX + (0, $0e5fd1585784c252$export$4e61f672936bec77)();\n        this.label = this.options.label || this.connectionId;\n        this.reliable = !!this.options.reliable;\n        this._negotiator = new (0, $b82fb8fc0514bfc1$export$89e6bb5ad64bf4a)(this);\n        this._negotiator.startConnection(this.options._payload || {\n            originator: true,\n            reliable: this.reliable\n        });\n    }\n    /** Called by the Negotiator when the DataChannel is ready. */ _initializeDataChannel(dc) {\n        this.dataChannel = dc;\n        this.dataChannel.onopen = ()=>{\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc connection success`);\n            this._open = true;\n            this.emit(\"open\");\n        };\n        this.dataChannel.onmessage = (e)=>{\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc onmessage:`, e.data);\n        // this._handleDataMessage(e);\n        };\n        this.dataChannel.onclose = ()=>{\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc closed for:`, this.peer);\n            this.close();\n        };\n    }\n    /**\n\t * Exposed functionality for users.\n\t */ /** Allows user to close connection. */ close(options) {\n        if (options?.flush) {\n            this.send({\n                __peerData: {\n                    type: \"close\"\n                }\n            });\n            return;\n        }\n        if (this._negotiator) {\n            this._negotiator.cleanup();\n            this._negotiator = null;\n        }\n        if (this.provider) {\n            this.provider._removeConnection(this);\n            this.provider = null;\n        }\n        if (this.dataChannel) {\n            this.dataChannel.onopen = null;\n            this.dataChannel.onmessage = null;\n            this.dataChannel.onclose = null;\n            this.dataChannel = null;\n        }\n        if (!this.open) return;\n        this._open = false;\n        super.emit(\"close\");\n    }\n    /** Allows user to send data. */ send(data, chunked = false) {\n        if (!this.open) {\n            this.emitError((0, $78455e22dea96b8c$export$49ae800c114df41d).NotOpenYet, \"Connection is not open. You should listen for the `open` event before sending messages.\");\n            return;\n        }\n        return this._send(data, chunked);\n    }\n    async handleMessage(message) {\n        const payload = message.payload;\n        switch(message.type){\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Answer:\n                await this._negotiator.handleSDP(message.type, payload.sdp);\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Candidate:\n                await this._negotiator.handleCandidate(payload.candidate);\n                break;\n            default:\n                (0, $257947e92926277a$export$2e2bcd8739ae039).warn(\"Unrecognized message type:\", message.type, \"from peer:\", this.peer);\n                break;\n        }\n    }\n}\n\n\nclass $a229bedbcaa6ca23$export$ff7c9d4c11d94e8b extends (0, $6366c4ca161bc297$export$d365f7ad9d7df9c9) {\n    get bufferSize() {\n        return this._bufferSize;\n    }\n    _initializeDataChannel(dc) {\n        super._initializeDataChannel(dc);\n        this.dataChannel.binaryType = \"arraybuffer\";\n        this.dataChannel.addEventListener(\"message\", (e)=>this._handleDataMessage(e));\n    }\n    _bufferedSend(msg) {\n        if (this._buffering || !this._trySend(msg)) {\n            this._buffer.push(msg);\n            this._bufferSize = this._buffer.length;\n        }\n    }\n    // Returns true if the send succeeds.\n    _trySend(msg) {\n        if (!this.open) return false;\n        if (this.dataChannel.bufferedAmount > (0, $6366c4ca161bc297$export$d365f7ad9d7df9c9).MAX_BUFFERED_AMOUNT) {\n            this._buffering = true;\n            setTimeout(()=>{\n                this._buffering = false;\n                this._tryBuffer();\n            }, 50);\n            return false;\n        }\n        try {\n            this.dataChannel.send(msg);\n        } catch (e) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).error(`DC#:${this.connectionId} Error when sending:`, e);\n            this._buffering = true;\n            this.close();\n            return false;\n        }\n        return true;\n    }\n    // Try to send the first message in the buffer.\n    _tryBuffer() {\n        if (!this.open) return;\n        if (this._buffer.length === 0) return;\n        const msg = this._buffer[0];\n        if (this._trySend(msg)) {\n            this._buffer.shift();\n            this._bufferSize = this._buffer.length;\n            this._tryBuffer();\n        }\n    }\n    close(options) {\n        if (options?.flush) {\n            this.send({\n                __peerData: {\n                    type: \"close\"\n                }\n            });\n            return;\n        }\n        this._buffer = [];\n        this._bufferSize = 0;\n        super.close();\n    }\n    constructor(...args){\n        super(...args);\n        this._buffer = [];\n        this._bufferSize = 0;\n        this._buffering = false;\n    }\n}\n\n\n\n\nclass $9fcfddb3ae148f88$export$f0a5a64d5bb37108 extends (0, $a229bedbcaa6ca23$export$ff7c9d4c11d94e8b) {\n    close(options) {\n        super.close(options);\n        this._chunkedData = {};\n    }\n    constructor(peerId, provider, options){\n        super(peerId, provider, options);\n        this.chunker = new (0, $fcbcc7538a6776d5$export$f1c5f4c9cb95390b)();\n        this.serialization = (0, $78455e22dea96b8c$export$89f507cf986a947).Binary;\n        this._chunkedData = {};\n    }\n    // Handles a DataChannel message.\n    _handleDataMessage({ data: data }) {\n        const deserializedData = (0, peerjs_js_binarypack__WEBPACK_IMPORTED_MODULE_0__.unpack)(data);\n        // PeerJS specific message\n        const peerData = deserializedData[\"__peerData\"];\n        if (peerData) {\n            if (peerData.type === \"close\") {\n                this.close();\n                return;\n            }\n            // Chunked data -- piece things back together.\n            // @ts-ignore\n            this._handleChunk(deserializedData);\n            return;\n        }\n        this.emit(\"data\", deserializedData);\n    }\n    _handleChunk(data) {\n        const id = data.__peerData;\n        const chunkInfo = this._chunkedData[id] || {\n            data: [],\n            count: 0,\n            total: data.total\n        };\n        chunkInfo.data[data.n] = new Uint8Array(data.data);\n        chunkInfo.count++;\n        this._chunkedData[id] = chunkInfo;\n        if (chunkInfo.total === chunkInfo.count) {\n            // Clean up before making the recursive call to `_handleDataMessage`.\n            delete this._chunkedData[id];\n            // We've received all the chunks--time to construct the complete data.\n            // const data = new Blob(chunkInfo.data);\n            const data = (0, $fcbcc7538a6776d5$export$52c89ebcdc4f53f2)(chunkInfo.data);\n            this._handleDataMessage({\n                data: data\n            });\n        }\n    }\n    _send(data, chunked) {\n        const blob = (0, peerjs_js_binarypack__WEBPACK_IMPORTED_MODULE_0__.pack)(data);\n        if (blob instanceof Promise) return this._send_blob(blob);\n        if (!chunked && blob.byteLength > this.chunker.chunkedMTU) {\n            this._sendChunks(blob);\n            return;\n        }\n        this._bufferedSend(blob);\n    }\n    async _send_blob(blobPromise) {\n        const blob = await blobPromise;\n        if (blob.byteLength > this.chunker.chunkedMTU) {\n            this._sendChunks(blob);\n            return;\n        }\n        this._bufferedSend(blob);\n    }\n    _sendChunks(blob) {\n        const blobs = this.chunker.chunk(blob);\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(`DC#${this.connectionId} Try to send ${blobs.length} chunks...`);\n        for (const blob of blobs)this.send(blob, true);\n    }\n}\n\n\n\n\nclass $bbaee3f15f714663$export$6f88fe47d32c9c94 extends (0, $a229bedbcaa6ca23$export$ff7c9d4c11d94e8b) {\n    _handleDataMessage({ data: data }) {\n        super.emit(\"data\", data);\n    }\n    _send(data, _chunked) {\n        this._bufferedSend(data);\n    }\n    constructor(...args){\n        super(...args);\n        this.serialization = (0, $78455e22dea96b8c$export$89f507cf986a947).None;\n    }\n}\n\n\n\n\n\nclass $817f931e3f9096cf$export$48880ac635f47186 extends (0, $a229bedbcaa6ca23$export$ff7c9d4c11d94e8b) {\n    // Handles a DataChannel message.\n    _handleDataMessage({ data: data }) {\n        const deserializedData = this.parse(this.decoder.decode(data));\n        // PeerJS specific message\n        const peerData = deserializedData[\"__peerData\"];\n        if (peerData && peerData.type === \"close\") {\n            this.close();\n            return;\n        }\n        this.emit(\"data\", deserializedData);\n    }\n    _send(data, _chunked) {\n        const encodedData = this.encoder.encode(this.stringify(data));\n        if (encodedData.byteLength >= (0, $4f4134156c446392$export$7debb50ef11d5e0b).chunkedMTU) {\n            this.emitError((0, $78455e22dea96b8c$export$49ae800c114df41d).MessageToBig, \"Message too big for JSON channel\");\n            return;\n        }\n        this._bufferedSend(encodedData);\n    }\n    constructor(...args){\n        super(...args);\n        this.serialization = (0, $78455e22dea96b8c$export$89f507cf986a947).JSON;\n        this.encoder = new TextEncoder();\n        this.decoder = new TextDecoder();\n        this.stringify = JSON.stringify;\n        this.parse = JSON.parse;\n    }\n}\n\n\n\nclass $416260bce337df90$var$PeerOptions {\n}\nclass $416260bce337df90$export$ecd1fc136c422448 extends (0, $23779d1881157a18$export$6a678e589c8a4542) {\n    static #_ = this.DEFAULT_KEY = \"peerjs\";\n    /**\n\t * The brokering ID of this peer\n\t *\n\t * If no ID was specified in {@apilink Peer | the constructor},\n\t * this will be `undefined` until the {@apilink PeerEvents | `open`} event is emitted.\n\t */ get id() {\n        return this._id;\n    }\n    get options() {\n        return this._options;\n    }\n    get open() {\n        return this._open;\n    }\n    /**\n\t * @internal\n\t */ get socket() {\n        return this._socket;\n    }\n    /**\n\t * A hash of all connections associated with this peer, keyed by the remote peer's ID.\n\t * @deprecated\n\t * Return type will change from Object to Map<string,[]>\n\t */ get connections() {\n        const plainConnections = Object.create(null);\n        for (const [k, v] of this._connections)plainConnections[k] = v;\n        return plainConnections;\n    }\n    /**\n\t * true if this peer and all of its connections can no longer be used.\n\t */ get destroyed() {\n        return this._destroyed;\n    }\n    /**\n\t * false if there is an active connection to the PeerServer.\n\t */ get disconnected() {\n        return this._disconnected;\n    }\n    constructor(id, options){\n        super();\n        this._serializers = {\n            raw: (0, $bbaee3f15f714663$export$6f88fe47d32c9c94),\n            json: (0, $817f931e3f9096cf$export$48880ac635f47186),\n            binary: (0, $9fcfddb3ae148f88$export$f0a5a64d5bb37108),\n            \"binary-utf8\": (0, $9fcfddb3ae148f88$export$f0a5a64d5bb37108),\n            default: (0, $9fcfddb3ae148f88$export$f0a5a64d5bb37108)\n        };\n        this._id = null;\n        this._lastServerId = null;\n        // States.\n        this._destroyed = false // Connections have been killed\n        ;\n        this._disconnected = false // Connection to PeerServer killed but P2P connections still active\n        ;\n        this._open = false // Sockets and such are not yet open.\n        ;\n        this._connections = new Map() // All connections for this peer.\n        ;\n        this._lostMessages = new Map() // src => [list of messages]\n        ;\n        let userId;\n        // Deal with overloading\n        if (id && id.constructor == Object) options = id;\n        else if (id) userId = id.toString();\n        // Configurize options\n        options = {\n            debug: 0,\n            host: (0, $4f4134156c446392$export$7debb50ef11d5e0b).CLOUD_HOST,\n            port: (0, $4f4134156c446392$export$7debb50ef11d5e0b).CLOUD_PORT,\n            path: \"/\",\n            key: $416260bce337df90$export$ecd1fc136c422448.DEFAULT_KEY,\n            token: (0, $4f4134156c446392$export$7debb50ef11d5e0b).randomToken(),\n            config: (0, $4f4134156c446392$export$7debb50ef11d5e0b).defaultConfig,\n            referrerPolicy: \"strict-origin-when-cross-origin\",\n            serializers: {},\n            ...options\n        };\n        this._options = options;\n        this._serializers = {\n            ...this._serializers,\n            ...this.options.serializers\n        };\n        // Detect relative URL host.\n        if (this._options.host === \"/\") this._options.host = window.location.hostname;\n        // Set path correctly.\n        if (this._options.path) {\n            if (this._options.path[0] !== \"/\") this._options.path = \"/\" + this._options.path;\n            if (this._options.path[this._options.path.length - 1] !== \"/\") this._options.path += \"/\";\n        }\n        // Set whether we use SSL to same as current host\n        if (this._options.secure === undefined && this._options.host !== (0, $4f4134156c446392$export$7debb50ef11d5e0b).CLOUD_HOST) this._options.secure = (0, $4f4134156c446392$export$7debb50ef11d5e0b).isSecure();\n        else if (this._options.host == (0, $4f4134156c446392$export$7debb50ef11d5e0b).CLOUD_HOST) this._options.secure = true;\n        // Set a custom log function if present\n        if (this._options.logFunction) (0, $257947e92926277a$export$2e2bcd8739ae039).setLogFunction(this._options.logFunction);\n        (0, $257947e92926277a$export$2e2bcd8739ae039).logLevel = this._options.debug || 0;\n        this._api = new (0, $abf266641927cd89$export$2c4e825dc9120f87)(options);\n        this._socket = this._createServerConnection();\n        // Sanity checks\n        // Ensure WebRTC supported\n        if (!(0, $4f4134156c446392$export$7debb50ef11d5e0b).supports.audioVideo && !(0, $4f4134156c446392$export$7debb50ef11d5e0b).supports.data) {\n            this._delayedAbort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).BrowserIncompatible, \"The current browser does not support WebRTC\");\n            return;\n        }\n        // Ensure alphanumeric id\n        if (!!userId && !(0, $4f4134156c446392$export$7debb50ef11d5e0b).validateId(userId)) {\n            this._delayedAbort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).InvalidID, `ID \"${userId}\" is invalid`);\n            return;\n        }\n        if (userId) this._initialize(userId);\n        else this._api.retrieveId().then((id)=>this._initialize(id)).catch((error)=>this._abort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).ServerError, error));\n    }\n    _createServerConnection() {\n        const socket = new (0, $8f5bfa60836d261d$export$4798917dbf149b79)(this._options.secure, this._options.host, this._options.port, this._options.path, this._options.key, this._options.pingInterval);\n        socket.on((0, $78455e22dea96b8c$export$3b5c4a4b6354f023).Message, (data)=>{\n            this._handleMessage(data);\n        });\n        socket.on((0, $78455e22dea96b8c$export$3b5c4a4b6354f023).Error, (error)=>{\n            this._abort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).SocketError, error);\n        });\n        socket.on((0, $78455e22dea96b8c$export$3b5c4a4b6354f023).Disconnected, ()=>{\n            if (this.disconnected) return;\n            this.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).Network, \"Lost connection to server.\");\n            this.disconnect();\n        });\n        socket.on((0, $78455e22dea96b8c$export$3b5c4a4b6354f023).Close, ()=>{\n            if (this.disconnected) return;\n            this._abort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).SocketClosed, \"Underlying socket is already closed.\");\n        });\n        return socket;\n    }\n    /** Initialize a connection with the server. */ _initialize(id) {\n        this._id = id;\n        this.socket.start(id, this._options.token);\n    }\n    /** Handles messages from the server. */ _handleMessage(message) {\n        const type = message.type;\n        const payload = message.payload;\n        const peerId = message.src;\n        switch(type){\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Open:\n                this._lastServerId = this.id;\n                this._open = true;\n                this.emit(\"open\", this.id);\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Error:\n                this._abort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).ServerError, payload.msg);\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).IdTaken:\n                this._abort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).UnavailableID, `ID \"${this.id}\" is taken`);\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).InvalidKey:\n                this._abort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).InvalidKey, `API KEY \"${this._options.key}\" is invalid`);\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Leave:\n                (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Received leave message from ${peerId}`);\n                this._cleanupPeer(peerId);\n                this._connections.delete(peerId);\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Expire:\n                this.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).PeerUnavailable, `Could not connect to peer ${peerId}`);\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Offer:\n                {\n                    // we should consider switching this to CALL/CONNECT, but this is the least breaking option.\n                    const connectionId = payload.connectionId;\n                    let connection = this.getConnection(peerId, connectionId);\n                    if (connection) {\n                        connection.close();\n                        (0, $257947e92926277a$export$2e2bcd8739ae039).warn(`Offer received for existing Connection ID:${connectionId}`);\n                    }\n                    // Create a new connection.\n                    if (payload.type === (0, $78455e22dea96b8c$export$3157d57b4135e3bc).Media) {\n                        const mediaConnection = new (0, $5c1d08c7c57da9a3$export$4a84e95a2324ac29)(peerId, this, {\n                            connectionId: connectionId,\n                            _payload: payload,\n                            metadata: payload.metadata\n                        });\n                        connection = mediaConnection;\n                        this._addConnection(peerId, connection);\n                        this.emit(\"call\", mediaConnection);\n                    } else if (payload.type === (0, $78455e22dea96b8c$export$3157d57b4135e3bc).Data) {\n                        const dataConnection = new this._serializers[payload.serialization](peerId, this, {\n                            connectionId: connectionId,\n                            _payload: payload,\n                            metadata: payload.metadata,\n                            label: payload.label,\n                            serialization: payload.serialization,\n                            reliable: payload.reliable\n                        });\n                        connection = dataConnection;\n                        this._addConnection(peerId, connection);\n                        this.emit(\"connection\", dataConnection);\n                    } else {\n                        (0, $257947e92926277a$export$2e2bcd8739ae039).warn(`Received malformed connection type:${payload.type}`);\n                        return;\n                    }\n                    // Find messages.\n                    const messages = this._getMessages(connectionId);\n                    for (const message of messages)connection.handleMessage(message);\n                    break;\n                }\n            default:\n                {\n                    if (!payload) {\n                        (0, $257947e92926277a$export$2e2bcd8739ae039).warn(`You received a malformed message from ${peerId} of type ${type}`);\n                        return;\n                    }\n                    const connectionId = payload.connectionId;\n                    const connection = this.getConnection(peerId, connectionId);\n                    if (connection && connection.peerConnection) // Pass it on.\n                    connection.handleMessage(message);\n                    else if (connectionId) // Store for possible later use\n                    this._storeMessage(connectionId, message);\n                    else (0, $257947e92926277a$export$2e2bcd8739ae039).warn(\"You received an unrecognized message:\", message);\n                    break;\n                }\n        }\n    }\n    /** Stores messages without a set up connection, to be claimed later. */ _storeMessage(connectionId, message) {\n        if (!this._lostMessages.has(connectionId)) this._lostMessages.set(connectionId, []);\n        this._lostMessages.get(connectionId).push(message);\n    }\n    /**\n\t * Retrieve messages from lost message store\n\t * @internal\n\t */ //TODO Change it to private\n    _getMessages(connectionId) {\n        const messages = this._lostMessages.get(connectionId);\n        if (messages) {\n            this._lostMessages.delete(connectionId);\n            return messages;\n        }\n        return [];\n    }\n    /**\n\t * Connects to the remote peer specified by id and returns a data connection.\n\t * @param peer The brokering ID of the remote peer (their {@apilink Peer.id}).\n\t * @param options for specifying details about Peer Connection\n\t */ connect(peer, options = {}) {\n        options = {\n            serialization: \"default\",\n            ...options\n        };\n        if (this.disconnected) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).warn(\"You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect, or call reconnect on this peer if you believe its ID to still be available.\");\n            this.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).Disconnected, \"Cannot connect to new Peer after disconnecting from server.\");\n            return;\n        }\n        const dataConnection = new this._serializers[options.serialization](peer, this, options);\n        this._addConnection(peer, dataConnection);\n        return dataConnection;\n    }\n    /**\n\t * Calls the remote peer specified by id and returns a media connection.\n\t * @param peer The brokering ID of the remote peer (their peer.id).\n\t * @param stream The caller's media stream\n\t * @param options Metadata associated with the connection, passed in by whoever initiated the connection.\n\t */ call(peer, stream, options = {}) {\n        if (this.disconnected) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).warn(\"You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect.\");\n            this.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).Disconnected, \"Cannot connect to new Peer after disconnecting from server.\");\n            return;\n        }\n        if (!stream) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).error(\"To call a peer, you must provide a stream from your browser's `getUserMedia`.\");\n            return;\n        }\n        const mediaConnection = new (0, $5c1d08c7c57da9a3$export$4a84e95a2324ac29)(peer, this, {\n            ...options,\n            _stream: stream\n        });\n        this._addConnection(peer, mediaConnection);\n        return mediaConnection;\n    }\n    /** Add a data/media connection to this peer. */ _addConnection(peerId, connection) {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(`add connection ${connection.type}:${connection.connectionId} to peerId:${peerId}`);\n        if (!this._connections.has(peerId)) this._connections.set(peerId, []);\n        this._connections.get(peerId).push(connection);\n    }\n    //TODO should be private\n    _removeConnection(connection) {\n        const connections = this._connections.get(connection.peer);\n        if (connections) {\n            const index = connections.indexOf(connection);\n            if (index !== -1) connections.splice(index, 1);\n        }\n        //remove from lost messages\n        this._lostMessages.delete(connection.connectionId);\n    }\n    /** Retrieve a data/media connection for this peer. */ getConnection(peerId, connectionId) {\n        const connections = this._connections.get(peerId);\n        if (!connections) return null;\n        for (const connection of connections){\n            if (connection.connectionId === connectionId) return connection;\n        }\n        return null;\n    }\n    _delayedAbort(type, message) {\n        setTimeout(()=>{\n            this._abort(type, message);\n        }, 0);\n    }\n    /**\n\t * Emits an error message and destroys the Peer.\n\t * The Peer is not destroyed if it's in a disconnected state, in which case\n\t * it retains its disconnected state and its existing connections.\n\t */ _abort(type, message) {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).error(\"Aborting!\");\n        this.emitError(type, message);\n        if (!this._lastServerId) this.destroy();\n        else this.disconnect();\n    }\n    /**\n\t * Destroys the Peer: closes all active connections as well as the connection\n\t * to the server.\n\t *\n\t * :::caution\n\t * This cannot be undone; the respective peer object will no longer be able\n\t * to create or receive any connections, its ID will be forfeited on the server,\n\t * and all of its data and media connections will be closed.\n\t * :::\n\t */ destroy() {\n        if (this.destroyed) return;\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Destroy peer with ID:${this.id}`);\n        this.disconnect();\n        this._cleanup();\n        this._destroyed = true;\n        this.emit(\"close\");\n    }\n    /** Disconnects every connection on this peer. */ _cleanup() {\n        for (const peerId of this._connections.keys()){\n            this._cleanupPeer(peerId);\n            this._connections.delete(peerId);\n        }\n        this.socket.removeAllListeners();\n    }\n    /** Closes all connections to this peer. */ _cleanupPeer(peerId) {\n        const connections = this._connections.get(peerId);\n        if (!connections) return;\n        for (const connection of connections)connection.close();\n    }\n    /**\n\t * Disconnects the Peer's connection to the PeerServer. Does not close any\n\t *  active connections.\n\t * Warning: The peer can no longer create or accept connections after being\n\t *  disconnected. It also cannot reconnect to the server.\n\t */ disconnect() {\n        if (this.disconnected) return;\n        const currentId = this.id;\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Disconnect peer with ID:${currentId}`);\n        this._disconnected = true;\n        this._open = false;\n        this.socket.close();\n        this._lastServerId = currentId;\n        this._id = null;\n        this.emit(\"disconnected\", currentId);\n    }\n    /** Attempts to reconnect with the same ID.\n\t *\n\t * Only {@apilink Peer.disconnect | disconnected peers} can be reconnected.\n\t * Destroyed peers cannot be reconnected.\n\t * If the connection fails (as an example, if the peer's old ID is now taken),\n\t * the peer's existing connections will not close, but any associated errors events will fire.\n\t */ reconnect() {\n        if (this.disconnected && !this.destroyed) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Attempting reconnection to server with ID ${this._lastServerId}`);\n            this._disconnected = false;\n            this._initialize(this._lastServerId);\n        } else if (this.destroyed) throw new Error(\"This peer cannot reconnect to the server. It has already been destroyed.\");\n        else if (!this.disconnected && !this.open) // Do nothing. We're still connecting the first time.\n        (0, $257947e92926277a$export$2e2bcd8739ae039).error(\"In a hurry? We're still trying to make the initial connection!\");\n        else throw new Error(`Peer ${this.id} cannot reconnect because it is not disconnected from the server!`);\n    }\n    /**\n\t * Get a list of available peer IDs. If you're running your own server, you'll\n\t * want to set allow_discovery: true in the PeerServer options. If you're using\n\t * the cloud server, email team@peerjs.com to get the functionality enabled for\n\t * your key.\n\t */ listAllPeers(cb = (_)=>{}) {\n        this._api.listAllPeers().then((peers)=>cb(peers)).catch((error)=>this._abort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).ServerError, error));\n    }\n}\n\n\n\n\n\n\nclass $20dbe68149d7aad9$export$72aa44612e2200cd extends (0, $6366c4ca161bc297$export$d365f7ad9d7df9c9) {\n    constructor(peerId, provider, options){\n        super(peerId, provider, {\n            ...options,\n            reliable: true\n        });\n        this._CHUNK_SIZE = 32768;\n        this._splitStream = new TransformStream({\n            transform: (chunk, controller)=>{\n                for(let split = 0; split < chunk.length; split += this._CHUNK_SIZE)controller.enqueue(chunk.subarray(split, split + this._CHUNK_SIZE));\n            }\n        });\n        this._rawSendStream = new WritableStream({\n            write: async (chunk, controller)=>{\n                const openEvent = new Promise((resolve)=>this.dataChannel.addEventListener(\"bufferedamountlow\", resolve, {\n                        once: true\n                    }));\n                // if we can send the chunk now, send it\n                // if not, we wait until at least half of the sending buffer is free again\n                await (this.dataChannel.bufferedAmount <= (0, $6366c4ca161bc297$export$d365f7ad9d7df9c9).MAX_BUFFERED_AMOUNT - chunk.byteLength || openEvent);\n                // TODO: what can go wrong here?\n                try {\n                    this.dataChannel.send(chunk);\n                } catch (e) {\n                    (0, $257947e92926277a$export$2e2bcd8739ae039).error(`DC#:${this.connectionId} Error when sending:`, e);\n                    controller.error(e);\n                    this.close();\n                }\n            }\n        });\n        this.writer = this._splitStream.writable.getWriter();\n        this._rawReadStream = new ReadableStream({\n            start: (controller)=>{\n                this.once(\"open\", ()=>{\n                    this.dataChannel.addEventListener(\"message\", (e)=>{\n                        controller.enqueue(e.data);\n                    });\n                });\n            }\n        });\n        this._splitStream.readable.pipeTo(this._rawSendStream);\n    }\n    _initializeDataChannel(dc) {\n        super._initializeDataChannel(dc);\n        this.dataChannel.binaryType = \"arraybuffer\";\n        this.dataChannel.bufferedAmountLowThreshold = (0, $6366c4ca161bc297$export$d365f7ad9d7df9c9).MAX_BUFFERED_AMOUNT / 2;\n    }\n}\n\n\nclass $6e39230ab36396ad$export$80f5de1a66c4d624 extends (0, $20dbe68149d7aad9$export$72aa44612e2200cd) {\n    constructor(peerId, provider, options){\n        super(peerId, provider, options);\n        this.serialization = \"MsgPack\";\n        this._encoder = new (0, _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__.Encoder)();\n        (async ()=>{\n            for await (const msg of (0, _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__.decodeMultiStream)(this._rawReadStream)){\n                // @ts-ignore\n                if (msg.__peerData?.type === \"close\") {\n                    this.close();\n                    return;\n                }\n                this.emit(\"data\", msg);\n            }\n        })();\n    }\n    _send(data) {\n        return this.writer.write(this._encoder.encode(data));\n    }\n}\n\n\nclass $1e0aff16be2c328e$export$d72c7bf8eef50853 extends (0, $416260bce337df90$export$ecd1fc136c422448) {\n    constructor(...args){\n        super(...args);\n        this._serializers = {\n            MsgPack: $6e39230ab36396ad$export$80f5de1a66c4d624,\n            default: (0, $6e39230ab36396ad$export$80f5de1a66c4d624)\n        };\n    }\n}\n\n\n\n\n\n\n\nvar $dd0187d7f28e386f$export$2e2bcd8739ae039 = (0, $416260bce337df90$export$ecd1fc136c422448);\n\n\n\n//# sourceMappingURL=bundler.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGVlcmpzL2Rpc3QvYnVuZGxlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrRjtBQUNoQztBQUN3RDs7O0FBRzFHO0FBQ0EsK0JBQStCLHFEQUFxRDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQSxJQUFJLHNEQUFvQixpQkFBaUIsc0RBQW9CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGNBQWM7QUFDZCxZQUFZO0FBQ1osd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6Qiw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsbUJBQW1CO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLG1CQUFtQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsbUJBQW1CO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVFQUF1RSxtQkFBbUI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixVQUFVO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0NBQStDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkcsbUJBQW1CO0FBQzlIO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzQkFBc0I7QUFDekQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLCtFQUErRSxtQkFBbUI7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxREFBYztBQUM5QztBQUNBLHdDQUF3QywrREFBd0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBOzs7QUFHNjRCO0FBQzc0QiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9wZWVyanMvZGlzdC9idW5kbGVyLm1qcz81NDczIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7cGFjayBhcyAkZ0NjYlkkcGFjaywgdW5wYWNrIGFzICRnQ2NiWSR1bnBhY2t9IGZyb20gXCJwZWVyanMtanMtYmluYXJ5cGFja1wiO1xuaW1wb3J0ICRnQ2NiWSR3ZWJydGNhZGFwdGVyIGZyb20gXCJ3ZWJydGMtYWRhcHRlclwiO1xuaW1wb3J0IHtFbmNvZGVyIGFzICRnQ2NiWSRFbmNvZGVyLCBkZWNvZGVNdWx0aVN0cmVhbSBhcyAkZ0NjYlkkZGVjb2RlTXVsdGlTdHJlYW19IGZyb20gXCJAbXNncGFjay9tc2dwYWNrXCI7XG5cblxuZnVuY3Rpb24gJHBhcmNlbCRleHBvcnQoZSwgbiwgdiwgcykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgbiwge2dldDogdiwgc2V0OiBzLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9KTtcbn1cbmNsYXNzICRmY2JjYzc1MzhhNjc3NmQ1JGV4cG9ydCRmMWM1ZjRjOWNiOTUzOTBiIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmNodW5rZWRNVFUgPSAxNjMwMCAvLyBUaGUgb3JpZ2luYWwgNjAwMDAgYnl0ZXMgc2V0dGluZyBkb2VzIG5vdCB3b3JrIHdoZW4gc2VuZGluZyBkYXRhIGZyb20gRmlyZWZveCB0byBDaHJvbWUsIHdoaWNoIGlzIFwiY3V0IG9mZlwiIGFmdGVyIDE2Mzg0IGJ5dGVzIGFuZCBkZWxpdmVyZWQgaW5kaXZpZHVhbGx5LlxuICAgICAgICA7XG4gICAgICAgIC8vIEJpbmFyeSBzdHVmZlxuICAgICAgICB0aGlzLl9kYXRhQ291bnQgPSAxO1xuICAgICAgICB0aGlzLmNodW5rID0gKGJsb2IpPT57XG4gICAgICAgICAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBibG9iLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBjb25zdCB0b3RhbCA9IE1hdGguY2VpbChzaXplIC8gdGhpcy5jaHVua2VkTVRVKTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgICAgICAgd2hpbGUoc3RhcnQgPCBzaXplKXtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihzaXplLCBzdGFydCArIHRoaXMuY2h1bmtlZE1UVSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYiA9IGJsb2Iuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB7XG4gICAgICAgICAgICAgICAgICAgIF9fcGVlckRhdGE6IHRoaXMuX2RhdGFDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgbjogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGIsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsOiB0b3RhbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kYXRhQ291bnQrKztcbiAgICAgICAgICAgIHJldHVybiBjaHVua3M7XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gJGZjYmNjNzUzOGE2Nzc2ZDUkZXhwb3J0JDUyYzg5ZWJjZGM0ZjUzZjIoYnVmcykge1xuICAgIGxldCBzaXplID0gMDtcbiAgICBmb3IgKGNvbnN0IGJ1ZiBvZiBidWZzKXNpemUgKz0gYnVmLmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChjb25zdCBidWYgb2YgYnVmcyl7XG4gICAgICAgIHJlc3VsdC5zZXQoYnVmLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gYnVmLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cblxuXG5cbmNvbnN0ICRmYjYzZTc2NmNmYWZhYWI5JHZhciR3ZWJSVENBZGFwdGVyID0gLy9AdHMtaWdub3JlXG4oMCwgJGdDY2JZJHdlYnJ0Y2FkYXB0ZXIpLmRlZmF1bHQgfHwgKDAsICRnQ2NiWSR3ZWJydGNhZGFwdGVyKTtcbmNvbnN0ICRmYjYzZTc2NmNmYWZhYWI5JGV4cG9ydCQyNWJlOTUwMjQ3N2MxMzdkID0gbmV3IGNsYXNzIHtcbiAgICBpc1dlYlJUQ1N1cHBvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBSVENQZWVyQ29ubmVjdGlvbiAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICB9XG4gICAgaXNCcm93c2VyU3VwcG9ydGVkKCkge1xuICAgICAgICBjb25zdCBicm93c2VyID0gdGhpcy5nZXRCcm93c2VyKCk7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSB0aGlzLmdldFZlcnNpb24oKTtcbiAgICAgICAgY29uc3QgdmFsaWRCcm93c2VyID0gdGhpcy5zdXBwb3J0ZWRCcm93c2Vycy5pbmNsdWRlcyhicm93c2VyKTtcbiAgICAgICAgaWYgKCF2YWxpZEJyb3dzZXIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGJyb3dzZXIgPT09IFwiY2hyb21lXCIpIHJldHVybiB2ZXJzaW9uID49IHRoaXMubWluQ2hyb21lVmVyc2lvbjtcbiAgICAgICAgaWYgKGJyb3dzZXIgPT09IFwiZmlyZWZveFwiKSByZXR1cm4gdmVyc2lvbiA+PSB0aGlzLm1pbkZpcmVmb3hWZXJzaW9uO1xuICAgICAgICBpZiAoYnJvd3NlciA9PT0gXCJzYWZhcmlcIikgcmV0dXJuICF0aGlzLmlzSU9TICYmIHZlcnNpb24gPj0gdGhpcy5taW5TYWZhcmlWZXJzaW9uO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldEJyb3dzZXIoKSB7XG4gICAgICAgIHJldHVybiAkZmI2M2U3NjZjZmFmYWFiOSR2YXIkd2ViUlRDQWRhcHRlci5icm93c2VyRGV0YWlscy5icm93c2VyO1xuICAgIH1cbiAgICBnZXRWZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gJGZiNjNlNzY2Y2ZhZmFhYjkkdmFyJHdlYlJUQ0FkYXB0ZXIuYnJvd3NlckRldGFpbHMudmVyc2lvbiB8fCAwO1xuICAgIH1cbiAgICBpc1VuaWZpZWRQbGFuU3VwcG9ydGVkKCkge1xuICAgICAgICBjb25zdCBicm93c2VyID0gdGhpcy5nZXRCcm93c2VyKCk7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSAkZmI2M2U3NjZjZmFmYWFiOSR2YXIkd2ViUlRDQWRhcHRlci5icm93c2VyRGV0YWlscy52ZXJzaW9uIHx8IDA7XG4gICAgICAgIGlmIChicm93c2VyID09PSBcImNocm9tZVwiICYmIHZlcnNpb24gPCB0aGlzLm1pbkNocm9tZVZlcnNpb24pIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGJyb3dzZXIgPT09IFwiZmlyZWZveFwiICYmIHZlcnNpb24gPj0gdGhpcy5taW5GaXJlZm94VmVyc2lvbikgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICghd2luZG93LlJUQ1J0cFRyYW5zY2VpdmVyIHx8ICEoXCJjdXJyZW50RGlyZWN0aW9uXCIgaW4gUlRDUnRwVHJhbnNjZWl2ZXIucHJvdG90eXBlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgdGVtcFBjO1xuICAgICAgICBsZXQgc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0ZW1wUGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIHRlbXBQYy5hZGRUcmFuc2NlaXZlcihcImF1ZGlvXCIpO1xuICAgICAgICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge30gZmluYWxseXtcbiAgICAgICAgICAgIGlmICh0ZW1wUGMpIHRlbXBQYy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYFN1cHBvcnRzOlxuICAgIGJyb3dzZXI6JHt0aGlzLmdldEJyb3dzZXIoKX1cbiAgICB2ZXJzaW9uOiR7dGhpcy5nZXRWZXJzaW9uKCl9XG4gICAgaXNJT1M6JHt0aGlzLmlzSU9TfVxuICAgIGlzV2ViUlRDU3VwcG9ydGVkOiR7dGhpcy5pc1dlYlJUQ1N1cHBvcnRlZCgpfVxuICAgIGlzQnJvd3NlclN1cHBvcnRlZDoke3RoaXMuaXNCcm93c2VyU3VwcG9ydGVkKCl9XG4gICAgaXNVbmlmaWVkUGxhblN1cHBvcnRlZDoke3RoaXMuaXNVbmlmaWVkUGxhblN1cHBvcnRlZCgpfWA7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuaXNJT1MgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiID8gW1xuICAgICAgICAgICAgXCJpUGFkXCIsXG4gICAgICAgICAgICBcImlQaG9uZVwiLFxuICAgICAgICAgICAgXCJpUG9kXCJcbiAgICAgICAgXS5pbmNsdWRlcyhuYXZpZ2F0b3IucGxhdGZvcm0pIDogZmFsc2U7XG4gICAgICAgIHRoaXMuc3VwcG9ydGVkQnJvd3NlcnMgPSBbXG4gICAgICAgICAgICBcImZpcmVmb3hcIixcbiAgICAgICAgICAgIFwiY2hyb21lXCIsXG4gICAgICAgICAgICBcInNhZmFyaVwiXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMubWluRmlyZWZveFZlcnNpb24gPSA1OTtcbiAgICAgICAgdGhpcy5taW5DaHJvbWVWZXJzaW9uID0gNzI7XG4gICAgICAgIHRoaXMubWluU2FmYXJpVmVyc2lvbiA9IDYwNTtcbiAgICB9XG59KCk7XG5cblxuY29uc3QgJDlhODRhMzJiZjBiZjM2YmIkZXhwb3J0JGYzNWYxMjhmZDU5ZWEyNTYgPSAoaWQpPT57XG4gICAgLy8gQWxsb3cgZW1wdHkgaWRzXG4gICAgcmV0dXJuICFpZCB8fCAvXltBLVphLXowLTldKyg/OlsgXy1dW0EtWmEtejAtOV0rKSokLy50ZXN0KGlkKTtcbn07XG5cblxuY29uc3QgJDBlNWZkMTU4NTc4NGMyNTIkZXhwb3J0JDRlNjFmNjcyOTM2YmVjNzcgPSAoKT0+TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5cblxuY29uc3QgJDRmNDEzNDE1NmM0NDYzOTIkdmFyJERFRkFVTFRfQ09ORklHID0ge1xuICAgIGljZVNlcnZlcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgdXJsczogXCJzdHVuOnN0dW4ubC5nb29nbGUuY29tOjE5MzAyXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdXJsczogW1xuICAgICAgICAgICAgICAgIFwidHVybjpldS0wLnR1cm4ucGVlcmpzLmNvbTozNDc4XCIsXG4gICAgICAgICAgICAgICAgXCJ0dXJuOnVzLTAudHVybi5wZWVyanMuY29tOjM0NzhcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHVzZXJuYW1lOiBcInBlZXJqc1wiLFxuICAgICAgICAgICAgY3JlZGVudGlhbDogXCJwZWVyanNwXCJcbiAgICAgICAgfVxuICAgIF0sXG4gICAgc2RwU2VtYW50aWNzOiBcInVuaWZpZWQtcGxhblwiXG59O1xuY2xhc3MgJDRmNDEzNDE1NmM0NDYzOTIkZXhwb3J0JGY4ZjI2ZGQzOTVkN2UxYmQgZXh0ZW5kcyAoMCwgJGZjYmNjNzUzOGE2Nzc2ZDUkZXhwb3J0JGYxYzVmNGM5Y2I5NTM5MGIpIHtcbiAgICBub29wKCkge31cbiAgICBibG9iVG9BcnJheUJ1ZmZlcihibG9iLCBjYikge1xuICAgICAgICBjb25zdCBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgaWYgKGV2dC50YXJnZXQpIGNiKGV2dC50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgICAgZnIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gICAgICAgIHJldHVybiBmcjtcbiAgICB9XG4gICAgYmluYXJ5U3RyaW5nVG9BcnJheUJ1ZmZlcihiaW5hcnkpIHtcbiAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5Lmxlbmd0aCk7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBiaW5hcnkubGVuZ3RoOyBpKyspYnl0ZUFycmF5W2ldID0gYmluYXJ5LmNoYXJDb2RlQXQoaSkgJiAweGZmO1xuICAgICAgICByZXR1cm4gYnl0ZUFycmF5LmJ1ZmZlcjtcbiAgICB9XG4gICAgaXNTZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiBsb2NhdGlvbi5wcm90b2NvbCA9PT0gXCJodHRwczpcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLkNMT1VEX0hPU1QgPSBcIjAucGVlcmpzLmNvbVwiO1xuICAgICAgICB0aGlzLkNMT1VEX1BPUlQgPSA0NDM7XG4gICAgICAgIC8vIEJyb3dzZXJzIHRoYXQgbmVlZCBjaHVua2luZzpcbiAgICAgICAgdGhpcy5jaHVua2VkQnJvd3NlcnMgPSB7XG4gICAgICAgICAgICBDaHJvbWU6IDEsXG4gICAgICAgICAgICBjaHJvbWU6IDFcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmV0dXJucyBicm93c2VyLWFnbm9zdGljIGRlZmF1bHQgY29uZmlnXG4gICAgICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9ICQ0ZjQxMzQxNTZjNDQ2MzkyJHZhciRERUZBVUxUX0NPTkZJRztcbiAgICAgICAgdGhpcy5icm93c2VyID0gKDAsICRmYjYzZTc2NmNmYWZhYWI5JGV4cG9ydCQyNWJlOTUwMjQ3N2MxMzdkKS5nZXRCcm93c2VyKCk7XG4gICAgICAgIHRoaXMuYnJvd3NlclZlcnNpb24gPSAoMCwgJGZiNjNlNzY2Y2ZhZmFhYjkkZXhwb3J0JDI1YmU5NTAyNDc3YzEzN2QpLmdldFZlcnNpb24oKTtcbiAgICAgICAgdGhpcy5wYWNrID0gJGdDY2JZJHBhY2s7XG4gICAgICAgIHRoaXMudW5wYWNrID0gJGdDY2JZJHVucGFjaztcbiAgICAgICAgLyoqXG5cdCAqIEEgaGFzaCBvZiBXZWJSVEMgZmVhdHVyZXMgbWFwcGVkIHRvIGJvb2xlYW5zIHRoYXQgY29ycmVzcG9uZCB0byB3aGV0aGVyIHRoZSBmZWF0dXJlIGlzIHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCBicm93c2VyLlxuXHQgKlxuXHQgKiA6OjpjYXV0aW9uXG5cdCAqIE9ubHkgdGhlIHByb3BlcnRpZXMgZG9jdW1lbnRlZCBoZXJlIGFyZSBndWFyYW50ZWVkIHRvIGJlIHByZXNlbnQgb24gYHV0aWwuc3VwcG9ydHNgXG5cdCAqIDo6OlxuXHQgKi8gdGhpcy5zdXBwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc3Qgc3VwcG9ydGVkID0ge1xuICAgICAgICAgICAgICAgIGJyb3dzZXI6ICgwLCAkZmI2M2U3NjZjZmFmYWFiOSRleHBvcnQkMjViZTk1MDI0NzdjMTM3ZCkuaXNCcm93c2VyU3VwcG9ydGVkKCksXG4gICAgICAgICAgICAgICAgd2ViUlRDOiAoMCwgJGZiNjNlNzY2Y2ZhZmFhYjkkZXhwb3J0JDI1YmU5NTAyNDc3YzEzN2QpLmlzV2ViUlRDU3VwcG9ydGVkKCksXG4gICAgICAgICAgICAgICAgYXVkaW9WaWRlbzogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGF0YTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYmluYXJ5QmxvYjogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmVsaWFibGU6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFzdXBwb3J0ZWQud2ViUlRDKSByZXR1cm4gc3VwcG9ydGVkO1xuICAgICAgICAgICAgbGV0IHBjO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbigkNGY0MTM0MTU2YzQ0NjM5MiR2YXIkREVGQVVMVF9DT05GSUcpO1xuICAgICAgICAgICAgICAgIHN1cHBvcnRlZC5hdWRpb1ZpZGVvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsZXQgZGM7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGMgPSBwYy5jcmVhdGVEYXRhQ2hhbm5lbChcIl9QRUVSSlNURVNUXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyZWQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZC5kYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkLnJlbGlhYmxlID0gISFkYy5vcmRlcmVkO1xuICAgICAgICAgICAgICAgICAgICAvLyBCaW5hcnkgdGVzdFxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGMuYmluYXJ5VHlwZSA9IFwiYmxvYlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkLmJpbmFyeUJsb2IgPSAhKDAsICRmYjYzZTc2NmNmYWZhYWI5JGV4cG9ydCQyNWJlOTUwMjQ3N2MxMzdkKS5pc0lPUztcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGMpIGRjLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge30gZmluYWxseXtcbiAgICAgICAgICAgICAgICBpZiAocGMpIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3VwcG9ydGVkO1xuICAgICAgICB9KCk7XG4gICAgICAgIC8vIEVuc3VyZSBhbHBoYW51bWVyaWMgaWRzXG4gICAgICAgIHRoaXMudmFsaWRhdGVJZCA9ICgwLCAkOWE4NGEzMmJmMGJmMzZiYiRleHBvcnQkZjM1ZjEyOGZkNTllYTI1Nik7XG4gICAgICAgIHRoaXMucmFuZG9tVG9rZW4gPSAoMCwgJDBlNWZkMTU4NTc4NGMyNTIkZXhwb3J0JDRlNjFmNjcyOTM2YmVjNzcpO1xuICAgIH1cbn1cbmNvbnN0ICQ0ZjQxMzQxNTZjNDQ2MzkyJGV4cG9ydCQ3ZGViYjUwZWYxMWQ1ZTBiID0gbmV3ICQ0ZjQxMzQxNTZjNDQ2MzkyJGV4cG9ydCRmOGYyNmRkMzk1ZDdlMWJkKCk7XG5cblxuXG5jb25zdCAkMjU3OTQ3ZTkyOTI2Mjc3YSR2YXIkTE9HX1BSRUZJWCA9IFwiUGVlckpTOiBcIjtcbnZhciAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMjQzZTYyZDc4ZDNiNTQ0ZDtcbihmdW5jdGlvbihMb2dMZXZlbCkge1xuICAgIC8qKlxuXHQgKiBQcmludHMgbm8gbG9ncy5cblx0ICovIExvZ0xldmVsW0xvZ0xldmVsW1wiRGlzYWJsZWRcIl0gPSAwXSA9IFwiRGlzYWJsZWRcIjtcbiAgICAvKipcblx0ICogUHJpbnRzIG9ubHkgZXJyb3JzLlxuXHQgKi8gTG9nTGV2ZWxbTG9nTGV2ZWxbXCJFcnJvcnNcIl0gPSAxXSA9IFwiRXJyb3JzXCI7XG4gICAgLyoqXG5cdCAqIFByaW50cyBlcnJvcnMgYW5kIHdhcm5pbmdzLlxuXHQgKi8gTG9nTGV2ZWxbTG9nTGV2ZWxbXCJXYXJuaW5nc1wiXSA9IDJdID0gXCJXYXJuaW5nc1wiO1xuICAgIC8qKlxuXHQgKiBQcmludHMgYWxsIGxvZ3MuXG5cdCAqLyBMb2dMZXZlbFtMb2dMZXZlbFtcIkFsbFwiXSA9IDNdID0gXCJBbGxcIjtcbn0pKCQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyNDNlNjJkNzhkM2I1NDRkIHx8ICgkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMjQzZTYyZDc4ZDNiNTQ0ZCA9IHt9KSk7XG5jbGFzcyAkMjU3OTQ3ZTkyOTI2Mjc3YSR2YXIkTG9nZ2VyIHtcbiAgICBnZXQgbG9nTGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dMZXZlbDtcbiAgICB9XG4gICAgc2V0IGxvZ0xldmVsKGxvZ0xldmVsKSB7XG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gbG9nTGV2ZWw7XG4gICAgfVxuICAgIGxvZyguLi5hcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLl9sb2dMZXZlbCA+PSAzKSB0aGlzLl9wcmludCgzLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgd2FybiguLi5hcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLl9sb2dMZXZlbCA+PSAyKSB0aGlzLl9wcmludCgyLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgZXJyb3IoLi4uYXJncykge1xuICAgICAgICBpZiAodGhpcy5fbG9nTGV2ZWwgPj0gMSkgdGhpcy5fcHJpbnQoMSwgLi4uYXJncyk7XG4gICAgfVxuICAgIHNldExvZ0Z1bmN0aW9uKGZuKSB7XG4gICAgICAgIHRoaXMuX3ByaW50ID0gZm47XG4gICAgfVxuICAgIF9wcmludChsb2dMZXZlbCwgLi4ucmVzdCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gW1xuICAgICAgICAgICAgJDI1Nzk0N2U5MjkyNjI3N2EkdmFyJExPR19QUkVGSVgsXG4gICAgICAgICAgICAuLi5yZXN0XG4gICAgICAgIF07XG4gICAgICAgIGZvcihjb25zdCBpIGluIGNvcHkpaWYgKGNvcHlbaV0gaW5zdGFuY2VvZiBFcnJvcikgY29weVtpXSA9IFwiKFwiICsgY29weVtpXS5uYW1lICsgXCIpIFwiICsgY29weVtpXS5tZXNzYWdlO1xuICAgICAgICBpZiAobG9nTGV2ZWwgPj0gMykgY29uc29sZS5sb2coLi4uY29weSk7XG4gICAgICAgIGVsc2UgaWYgKGxvZ0xldmVsID49IDIpIGNvbnNvbGUud2FybihcIldBUk5JTkdcIiwgLi4uY29weSk7XG4gICAgICAgIGVsc2UgaWYgKGxvZ0xldmVsID49IDEpIGNvbnNvbGUuZXJyb3IoXCJFUlJPUlwiLCAuLi5jb3B5KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5fbG9nTGV2ZWwgPSAwO1xuICAgIH1cbn1cbnZhciAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5ID0gbmV3ICQyNTc5NDdlOTI5MjYyNzdhJHZhciRMb2dnZXIoKTtcblxuXG52YXIgJGM0ZGNmZDFkMWVhODY2NDckZXhwb3J0cyA9IHt9O1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgJGM0ZGNmZDFkMWVhODY2NDckdmFyJGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRwcmVmaXggPSBcIn5cIjtcbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRzKCkge31cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICAgICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAvL1xuICAgIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gICAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgICAvL1xuICAgIGlmICghbmV3ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudHMoKS5fX3Byb3RvX18pICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRwcmVmaXggPSBmYWxzZTtcbn1cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gJGM0ZGNmZDFkMWVhODY2NDckdmFyJEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gICAgdGhpcy5mbiA9IGZuO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgIHZhciBsaXN0ZW5lciA9IG5ldyAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSksIGV2dCA9ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRwcmVmaXggPyAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuICAgIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gICAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtcbiAgICAgICAgZW1pdHRlci5fZXZlbnRzW2V2dF0sXG4gICAgICAgIGxpc3RlbmVyXG4gICAgXTtcbiAgICByZXR1cm4gZW1pdHRlcjtcbn1cbi8qKlxuICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gJGM0ZGNmZDFkMWVhODY2NDckdmFyJGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gICAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRzKCk7XG4gICAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqLyBmdW5jdGlvbiAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRFbWl0dGVyKCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqLyAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgICB2YXIgbmFtZXMgPSBbXSwgZXZlbnRzLCBuYW1lO1xuICAgIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuICAgIGZvcihuYW1lIGluIGV2ZW50cyA9IHRoaXMuX2V2ZW50cylpZiAoJGM0ZGNmZDFkMWVhODY2NDckdmFyJGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2goJGM0ZGNmZDFkMWVhODY2NDckdmFyJHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICAgIHJldHVybiBuYW1lcztcbn07XG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi8gJGM0ZGNmZDFkMWVhODY2NDckdmFyJEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgdmFyIGV2dCA9ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRwcmVmaXggPyAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkcHJlZml4ICsgZXZlbnQgOiBldmVudCwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcbiAgICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gICAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW1xuICAgICAgICBoYW5kbGVycy5mblxuICAgIF07XG4gICAgZm9yKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgICByZXR1cm4gZWU7XG59O1xuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi8gJGM0ZGNmZDFkMWVhODY2NDckdmFyJEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICB2YXIgZXZ0ID0gJGM0ZGNmZDFkMWVhODY2NDckdmFyJHByZWZpeCA/ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRwcmVmaXggKyBldmVudCA6IGV2ZW50LCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcbiAgICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gICAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gICAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG59O1xuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi8gJGM0ZGNmZDFkMWVhODY2NDckdmFyJEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICAgIHZhciBldnQgPSAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkcHJlZml4ID8gJGM0ZGNmZDFkMWVhODY2NDckdmFyJHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncywgaTtcbiAgICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICBzd2l0Y2gobGVuKXtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7IGkgPCBsZW47IGkrKylhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aCwgajtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgICBzd2l0Y2gobGVuKXtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmdzKSBmb3IoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7IGogPCBsZW47IGorKylhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcbn07XG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICAgIHJldHVybiAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqLyAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICAgIHZhciBldnQgPSAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkcHJlZml4ID8gJGM0ZGNmZDFkMWVhODY2NDckdmFyJHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFmbikge1xuICAgICAgICAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuICAgIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICAgICAgaWYgKGxpc3RlbmVycy5mbiA9PT0gZm4gJiYgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJiAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpKSAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspaWYgKGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHwgb25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UgfHwgY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dCkgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgICAgICAvL1xuICAgICAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgICAgICBlbHNlICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi8gJGM0ZGNmZDFkMWVhODY2NDckdmFyJEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgdmFyIGV2dDtcbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgZXZ0ID0gJGM0ZGNmZDFkMWVhODY2NDckdmFyJHByZWZpeCA/ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgICAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudHMoKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG4kYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbiRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gJGM0ZGNmZDFkMWVhODY2NDckdmFyJEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuJGM0ZGNmZDFkMWVhODY2NDckdmFyJEV2ZW50RW1pdHRlci5wcmVmaXhlZCA9ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRwcmVmaXg7XG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG4kYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudEVtaXR0ZXI7XG4kYzRkY2ZkMWQxZWE4NjY0NyRleHBvcnRzID0gJGM0ZGNmZDFkMWVhODY2NDckdmFyJEV2ZW50RW1pdHRlcjtcblxuXG5cbnZhciAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnRzID0ge307XG5cbiRwYXJjZWwkZXhwb3J0KCQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydHMsIFwiQ29ubmVjdGlvblR5cGVcIiwgKCkgPT4gJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDMxNTdkNTdiNDEzNWUzYmMpO1xuJHBhcmNlbCRleHBvcnQoJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0cywgXCJQZWVyRXJyb3JUeXBlXCIsICgpID0+ICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmKTtcbiRwYXJjZWwkZXhwb3J0KCQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydHMsIFwiQmFzZUNvbm5lY3Rpb25FcnJvclR5cGVcIiwgKCkgPT4gJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDc5NzQ5MzU2ODYxNDk2ODYpO1xuJHBhcmNlbCRleHBvcnQoJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0cywgXCJEYXRhQ29ubmVjdGlvbkVycm9yVHlwZVwiLCAoKSA9PiAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkNDlhZTgwMGMxMTRkZjQxZCk7XG4kcGFyY2VsJGV4cG9ydCgkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnRzLCBcIlNlcmlhbGl6YXRpb25UeXBlXCIsICgpID0+ICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ4OWY1MDdjZjk4NmE5NDcpO1xuJHBhcmNlbCRleHBvcnQoJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0cywgXCJTb2NrZXRFdmVudFR5cGVcIiwgKCkgPT4gJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDNiNWM0YTRiNjM1NGYwMjMpO1xuJHBhcmNlbCRleHBvcnQoJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0cywgXCJTZXJ2ZXJNZXNzYWdlVHlwZVwiLCAoKSA9PiAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkYWRiNGExNzU0ZGE2ZjEwZCk7XG52YXIgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDMxNTdkNTdiNDEzNWUzYmM7XG4oZnVuY3Rpb24oQ29ubmVjdGlvblR5cGUpIHtcbiAgICBDb25uZWN0aW9uVHlwZVtcIkRhdGFcIl0gPSBcImRhdGFcIjtcbiAgICBDb25uZWN0aW9uVHlwZVtcIk1lZGlhXCJdID0gXCJtZWRpYVwiO1xufSkoJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDMxNTdkNTdiNDEzNWUzYmMgfHwgKCQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzMTU3ZDU3YjQxMzVlM2JjID0ge30pKTtcbnZhciAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkOTU0N2FhYTJlMzkwMzBmZjtcbihmdW5jdGlvbihQZWVyRXJyb3JUeXBlKSB7XG4gICAgLyoqXG5cdCAqIFRoZSBjbGllbnQncyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgc29tZSBvciBhbGwgV2ViUlRDIGZlYXR1cmVzIHRoYXQgeW91IGFyZSB0cnlpbmcgdG8gdXNlLlxuXHQgKi8gUGVlckVycm9yVHlwZVtcIkJyb3dzZXJJbmNvbXBhdGlibGVcIl0gPSBcImJyb3dzZXItaW5jb21wYXRpYmxlXCI7XG4gICAgLyoqXG5cdCAqIFlvdSd2ZSBhbHJlYWR5IGRpc2Nvbm5lY3RlZCB0aGlzIHBlZXIgZnJvbSB0aGUgc2VydmVyIGFuZCBjYW4gbm8gbG9uZ2VyIG1ha2UgYW55IG5ldyBjb25uZWN0aW9ucyBvbiBpdC5cblx0ICovIFBlZXJFcnJvclR5cGVbXCJEaXNjb25uZWN0ZWRcIl0gPSBcImRpc2Nvbm5lY3RlZFwiO1xuICAgIC8qKlxuXHQgKiBUaGUgSUQgcGFzc2VkIGludG8gdGhlIFBlZXIgY29uc3RydWN0b3IgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzLlxuXHQgKi8gUGVlckVycm9yVHlwZVtcIkludmFsaWRJRFwiXSA9IFwiaW52YWxpZC1pZFwiO1xuICAgIC8qKlxuXHQgKiBUaGUgQVBJIGtleSBwYXNzZWQgaW50byB0aGUgUGVlciBjb25zdHJ1Y3RvciBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMgb3IgaXMgbm90IGluIHRoZSBzeXN0ZW0gKGNsb3VkIHNlcnZlciBvbmx5KS5cblx0ICovIFBlZXJFcnJvclR5cGVbXCJJbnZhbGlkS2V5XCJdID0gXCJpbnZhbGlkLWtleVwiO1xuICAgIC8qKlxuXHQgKiBMb3N0IG9yIGNhbm5vdCBlc3RhYmxpc2ggYSBjb25uZWN0aW9uIHRvIHRoZSBzaWduYWxsaW5nIHNlcnZlci5cblx0ICovIFBlZXJFcnJvclR5cGVbXCJOZXR3b3JrXCJdID0gXCJuZXR3b3JrXCI7XG4gICAgLyoqXG5cdCAqIFRoZSBwZWVyIHlvdSdyZSB0cnlpbmcgdG8gY29ubmVjdCB0byBkb2VzIG5vdCBleGlzdC5cblx0ICovIFBlZXJFcnJvclR5cGVbXCJQZWVyVW5hdmFpbGFibGVcIl0gPSBcInBlZXItdW5hdmFpbGFibGVcIjtcbiAgICAvKipcblx0ICogUGVlckpTIGlzIGJlaW5nIHVzZWQgc2VjdXJlbHksIGJ1dCB0aGUgY2xvdWQgc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgU1NMLiBVc2UgYSBjdXN0b20gUGVlclNlcnZlci5cblx0ICovIFBlZXJFcnJvclR5cGVbXCJTc2xVbmF2YWlsYWJsZVwiXSA9IFwic3NsLXVuYXZhaWxhYmxlXCI7XG4gICAgLyoqXG5cdCAqIFVuYWJsZSB0byByZWFjaCB0aGUgc2VydmVyLlxuXHQgKi8gUGVlckVycm9yVHlwZVtcIlNlcnZlckVycm9yXCJdID0gXCJzZXJ2ZXItZXJyb3JcIjtcbiAgICAvKipcblx0ICogQW4gZXJyb3IgZnJvbSB0aGUgdW5kZXJseWluZyBzb2NrZXQuXG5cdCAqLyBQZWVyRXJyb3JUeXBlW1wiU29ja2V0RXJyb3JcIl0gPSBcInNvY2tldC1lcnJvclwiO1xuICAgIC8qKlxuXHQgKiBUaGUgdW5kZXJseWluZyBzb2NrZXQgY2xvc2VkIHVuZXhwZWN0ZWRseS5cblx0ICovIFBlZXJFcnJvclR5cGVbXCJTb2NrZXRDbG9zZWRcIl0gPSBcInNvY2tldC1jbG9zZWRcIjtcbiAgICAvKipcblx0ICogVGhlIElEIHBhc3NlZCBpbnRvIHRoZSBQZWVyIGNvbnN0cnVjdG9yIGlzIGFscmVhZHkgdGFrZW4uXG5cdCAqXG5cdCAqIDo6OmNhdXRpb25cblx0ICogVGhpcyBlcnJvciBpcyBub3QgZmF0YWwgaWYgeW91ciBwZWVyIGhhcyBvcGVuIHBlZXItdG8tcGVlciBjb25uZWN0aW9ucy5cblx0ICogVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBhdHRlbXB0IHRvIHtAYXBpbGluayBQZWVyLnJlY29ubmVjdH0gYSBwZWVyIHRoYXQgaGFzIGJlZW4gZGlzY29ubmVjdGVkIGZyb20gdGhlIHNlcnZlcixcblx0ICogYnV0IGl0cyBvbGQgSUQgaGFzIG5vdyBiZWVuIHRha2VuLlxuXHQgKiA6Ojpcblx0ICovIFBlZXJFcnJvclR5cGVbXCJVbmF2YWlsYWJsZUlEXCJdID0gXCJ1bmF2YWlsYWJsZS1pZFwiO1xuICAgIC8qKlxuXHQgKiBOYXRpdmUgV2ViUlRDIGVycm9ycy5cblx0ICovIFBlZXJFcnJvclR5cGVbXCJXZWJSVENcIl0gPSBcIndlYnJ0Y1wiO1xufSkoJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYgfHwgKCQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmID0ge30pKTtcbnZhciAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkNzk3NDkzNTY4NjE0OTY4NjtcbihmdW5jdGlvbihCYXNlQ29ubmVjdGlvbkVycm9yVHlwZSkge1xuICAgIEJhc2VDb25uZWN0aW9uRXJyb3JUeXBlW1wiTmVnb3RpYXRpb25GYWlsZWRcIl0gPSBcIm5lZ290aWF0aW9uLWZhaWxlZFwiO1xuICAgIEJhc2VDb25uZWN0aW9uRXJyb3JUeXBlW1wiQ29ubmVjdGlvbkNsb3NlZFwiXSA9IFwiY29ubmVjdGlvbi1jbG9zZWRcIjtcbn0pKCQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ3OTc0OTM1Njg2MTQ5Njg2IHx8ICgkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkNzk3NDkzNTY4NjE0OTY4NiA9IHt9KSk7XG52YXIgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDQ5YWU4MDBjMTE0ZGY0MWQ7XG4oZnVuY3Rpb24oRGF0YUNvbm5lY3Rpb25FcnJvclR5cGUpIHtcbiAgICBEYXRhQ29ubmVjdGlvbkVycm9yVHlwZVtcIk5vdE9wZW5ZZXRcIl0gPSBcIm5vdC1vcGVuLXlldFwiO1xuICAgIERhdGFDb25uZWN0aW9uRXJyb3JUeXBlW1wiTWVzc2FnZVRvQmlnXCJdID0gXCJtZXNzYWdlLXRvby1iaWdcIjtcbn0pKCQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ0OWFlODAwYzExNGRmNDFkIHx8ICgkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkNDlhZTgwMGMxMTRkZjQxZCA9IHt9KSk7XG52YXIgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDg5ZjUwN2NmOTg2YTk0NztcbihmdW5jdGlvbihTZXJpYWxpemF0aW9uVHlwZSkge1xuICAgIFNlcmlhbGl6YXRpb25UeXBlW1wiQmluYXJ5XCJdID0gXCJiaW5hcnlcIjtcbiAgICBTZXJpYWxpemF0aW9uVHlwZVtcIkJpbmFyeVVURjhcIl0gPSBcImJpbmFyeS11dGY4XCI7XG4gICAgU2VyaWFsaXphdGlvblR5cGVbXCJKU09OXCJdID0gXCJqc29uXCI7XG4gICAgU2VyaWFsaXphdGlvblR5cGVbXCJOb25lXCJdID0gXCJyYXdcIjtcbn0pKCQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ4OWY1MDdjZjk4NmE5NDcgfHwgKCQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ4OWY1MDdjZjk4NmE5NDcgPSB7fSkpO1xudmFyICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzYjVjNGE0YjYzNTRmMDIzO1xuKGZ1bmN0aW9uKFNvY2tldEV2ZW50VHlwZSkge1xuICAgIFNvY2tldEV2ZW50VHlwZVtcIk1lc3NhZ2VcIl0gPSBcIm1lc3NhZ2VcIjtcbiAgICBTb2NrZXRFdmVudFR5cGVbXCJEaXNjb25uZWN0ZWRcIl0gPSBcImRpc2Nvbm5lY3RlZFwiO1xuICAgIFNvY2tldEV2ZW50VHlwZVtcIkVycm9yXCJdID0gXCJlcnJvclwiO1xuICAgIFNvY2tldEV2ZW50VHlwZVtcIkNsb3NlXCJdID0gXCJjbG9zZVwiO1xufSkoJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDNiNWM0YTRiNjM1NGYwMjMgfHwgKCQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzYjVjNGE0YjYzNTRmMDIzID0ge30pKTtcbnZhciAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkYWRiNGExNzU0ZGE2ZjEwZDtcbihmdW5jdGlvbihTZXJ2ZXJNZXNzYWdlVHlwZSkge1xuICAgIFNlcnZlck1lc3NhZ2VUeXBlW1wiSGVhcnRiZWF0XCJdID0gXCJIRUFSVEJFQVRcIjtcbiAgICBTZXJ2ZXJNZXNzYWdlVHlwZVtcIkNhbmRpZGF0ZVwiXSA9IFwiQ0FORElEQVRFXCI7XG4gICAgU2VydmVyTWVzc2FnZVR5cGVbXCJPZmZlclwiXSA9IFwiT0ZGRVJcIjtcbiAgICBTZXJ2ZXJNZXNzYWdlVHlwZVtcIkFuc3dlclwiXSA9IFwiQU5TV0VSXCI7XG4gICAgU2VydmVyTWVzc2FnZVR5cGVbXCJPcGVuXCJdID0gXCJPUEVOXCI7XG4gICAgU2VydmVyTWVzc2FnZVR5cGVbXCJFcnJvclwiXSA9IFwiRVJST1JcIjtcbiAgICBTZXJ2ZXJNZXNzYWdlVHlwZVtcIklkVGFrZW5cIl0gPSBcIklELVRBS0VOXCI7XG4gICAgU2VydmVyTWVzc2FnZVR5cGVbXCJJbnZhbGlkS2V5XCJdID0gXCJJTlZBTElELUtFWVwiO1xuICAgIFNlcnZlck1lc3NhZ2VUeXBlW1wiTGVhdmVcIl0gPSBcIkxFQVZFXCI7XG4gICAgU2VydmVyTWVzc2FnZVR5cGVbXCJFeHBpcmVcIl0gPSBcIkVYUElSRVwiO1xufSkoJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JGFkYjRhMTc1NGRhNmYxMGQgfHwgKCQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCRhZGI0YTE3NTRkYTZmMTBkID0ge30pKTtcblxuXG52YXIgJGY1Zjg4MWVjNDU3NWYxZmMkZXhwb3J0cyA9IHt9O1xuJGY1Zjg4MWVjNDU3NWYxZmMkZXhwb3J0cyA9IEpTT04ucGFyc2UoJ3tcIm5hbWVcIjpcInBlZXJqc1wiLFwidmVyc2lvblwiOlwiMS41LjRcIixcImtleXdvcmRzXCI6W1wicGVlcmpzXCIsXCJ3ZWJydGNcIixcInAycFwiLFwicnRjXCJdLFwiZGVzY3JpcHRpb25cIjpcIlBlZXJKUyBjbGllbnRcIixcImhvbWVwYWdlXCI6XCJodHRwczovL3BlZXJqcy5jb21cIixcImJ1Z3NcIjp7XCJ1cmxcIjpcImh0dHBzOi8vZ2l0aHViLmNvbS9wZWVycy9wZWVyanMvaXNzdWVzXCJ9LFwicmVwb3NpdG9yeVwiOntcInR5cGVcIjpcImdpdFwiLFwidXJsXCI6XCJodHRwczovL2dpdGh1Yi5jb20vcGVlcnMvcGVlcmpzXCJ9LFwibGljZW5zZVwiOlwiTUlUXCIsXCJjb250cmlidXRvcnNcIjpbXCJNaWNoZWxsZSBCdSA8bWljaGVsbGVAbWljaGVsbGVidS5jb20+XCIsXCJhZnJva2ljayA8ZGV2YnlydUBnbWFpbC5jb20+XCIsXCJlcmljeiA8cmVhbGx5LmV6QGdtYWlsLmNvbT5cIixcIkphaXJvIDxraWRhbmRjYXRAZ21haWwuY29tPlwiLFwiSm9uYXMgR2xvbmluZyA8MzQxOTQzNzAram9uYXNnbG9uaW5nQHVzZXJzLm5vcmVwbHkuZ2l0aHViLmNvbT5cIixcIkphaXJvIENhcm8tQWNjaW5vIFZpY2lhbmEgPGphaXJvQGdhbGF4LmJlPlwiLFwiQ2FybG9zIENhYmFsbGVybyA8Y2FybG9zLmNhYmFsbGVyby5nb256YWxlekBnbWFpbC5jb20+XCIsXCJoYyA8aGhlZW5ucnJ5eUBnbWFpbC5jb20+XCIsXCJNdWhhbW1hZCBBc2lmIDxjYXByaXBpb0BnbWFpbC5jb20+XCIsXCJQcmFzaG9vbkIgPHByYXNob29uYmhhdHRhY2hhcmplZUBnbWFpbC5jb20+XCIsXCJIYXJzaCBCYXJkaGFuIE1pc2hyYSA8NDczNTEwMjUrSGFyc2hDYXNwZXJAdXNlcnMubm9yZXBseS5naXRodWIuY29tPlwiLFwiYWtvdHluc2tpIDxhbGVrc2FuZGVya290YnVyeUBnbWFpbC5jb20+XCIsXCJsbWIgPGlAbG1iLmlvPlwiLFwiSmFpcm9vbyA8amFpcm9jYXJvQG1zbi5jb20+XCIsXCJNb3JpdHogU3RcXHhmY2NrbGVyIDxtb3JpdHouc3R1ZWNrbGVyQGdtYWlsLmNvbT5cIixcIlNpbW9uIDxjcnlkb3RzbmFrZWdpdGh1YkBnbWFpbC5jb20+XCIsXCJEZW5pcyBMdWtvdiA8ZGVuaXNtYXNzdGVyc0BnbWFpbC5jb20+XCIsXCJQaGlsaXBwIEhhbmNrZSA8ZmlwcG9AYW5keWV0Lm5ldD5cIixcIkhhbnMgT2tzZW5kYWhsIDxoYW5zb2tzZW5kYWhsQGdtYWlsLmNvbT5cIixcIkplc3MgPGplc3NhY2hhbmRsZXJAZ21haWwuY29tPlwiLFwia2hhbmt1YW4gPGtoYW5rdWFuQGdtYWlsLmNvbT5cIixcIkRVT0RWSyA8a3VybWFub3Yud29ya0BnbWFpbC5jb20+XCIsXCJYaVpoYW8gPGt3YW5nMWltc2FAZ21haWwuY29tPlwiLFwiTWF0dGhpYXMgTG9ociA8bWF0dGhpYXNAbG9oci5tZT5cIixcIj1mcmFuayB0cmVlIDw9ZnJua3RyYkBnb29nbGVtYWlsLmNvbT5cIixcIkFuZHJlIEVja2FyZHQgPGFlY2thcmR0QG91dGxvb2suY29tPlwiLFwiQ2hyaXMgQ293YW4gPGFnZW50bWU0OUBnbWFpbC5jb20+XCIsXCJBbGV4IENodWV2IDxhbGV4QGNodWV2LmNvbT5cIixcImFseG51bGwgPGFseG51bGxAZS5tYWlsLmRlPlwiLFwiWWVtZWwgSmFyZGkgPGFuZ2VsLmphcmRpQGdtYWlsLmNvbT5cIixcIkJlbiBQYXJuZWxsIDxiZW5qYW1pbnBhcm5lbGwuOTRAZ21haWwuY29tPlwiLFwiQmVubnkgTGljaHRuZXIgPGJlbm5saWNoQGdtYWlsLmNvbT5cIixcImZyZXNoZW5lZXN6IDxiaXRldHJ1ZHB1YmxpY0BnbWFpbC5jb20+XCIsXCJib2IuYmFyc3RlYWRAZXhhcHRpdmUuY29tIDxib2IuYmFyc3RlYWRAZXhhcHRpdmUuY29tPlwiLFwiY2hhbmRpa2EgPGNoYW5kaWthQGdtYWlsLmNvbT5cIixcImVtZXJzaW9uIDxjb250YWN0QGVtZXJzaW9uLmZyPlwiLFwiQ2hyaXN0b3BoZXIgVmFuIDxjdmFuQHVzZXJzLm5vcmVwbHkuZ2l0aHViLmNvbT5cIixcImVkZGllaGVybSA8ZWRoZXJtb3NvQGdtYWlsLmNvbT5cIixcIkVkdWFyZG8gUGluaG8gPGVuZXQ0bWlrZWVuZXRAZ21haWwuY29tPlwiLFwiRXZhbmRybyBaYW5hdHRhIDxlemFuYXR0YUB0cmF5Lm5ldC5icj5cIixcIkdhcmRuZXIgQmlja2ZvcmQgPGdhcmRuZXJAdXNlcnMubm9yZXBseS5naXRodWIuY29tPlwiLFwiR2lhbiBMdWNhIDxnaWFubHVjYS5jZWNjaGlAY3lubnkuY29tPlwiLFwiUGF0cmlja0pTIDxnaXRodWJAZ2RpMjI5MC5jb20+XCIsXCJqb25ueWYgPGdpdGh1YkBqb25hdGhhbmZvc3MuY28udWs+XCIsXCJIaXpraWEgRmVsaXggPGhpemtpZndAZ21haWwuY29tPlwiLFwiSHJpc3RvIE9za292IDxocmlzdG8ub3Nrb3ZAZ21haWwuY29tPlwiLFwiSXNhYWMgTWFkd2VkIDxpLm1hZHdlZEBnbWFpbC5jb20+XCIsXCJJbHlhIEtvbmFueWtoaW4gPGlseWEua29uYW55a2hpbkBnbWFpbC5jb20+XCIsXCJqYXNvbmJhcnJ5IDxqYXNiYXJyeUBtZS5jb20+XCIsXCJKb25hdGhhbiBCdXJrZSA8am9uYXRoYW4uYnVya2UuMTMxMUBnb29nbGVtYWlsLmNvbT5cIixcIkpvc2ggSGFtaXQgPGpvc2guaGFtaXRAZ21haWwuY29tPlwiLFwiSm9yZGFuIEF1c3RpbiA8anJheDg2QGdtYWlsLmNvbT5cIixcIkpvZWwgV2V0emVsbCA8andldHplbGxAeWFob28uY29tPlwiLFwieGl6aGFvIDxrZXZpbi53YW5nQGNsb3VkZXJhLmNvbT5cIixcIkFsYmVydG8gVG9ycmVzIDxrdW5nZm9vYmFyQGdtYWlsLmNvbT5cIixcIkpvbmF0aGFuIE1heW9sIDxtYXlvbGpvbmF0aGFuQGdtYWlsLmNvbT5cIixcIkplZmZlcnNvbiBGZWxpeCA8bWVAanNmZWxpeC5kZXY+XCIsXCJSb2xmIEVyaWsgTGVrYW5nIDxtZUByb2xmbGVrYW5nLmNvbT5cIixcIktldmluIE1haS1IdXNhbiBDaGlhIDxtaGNoaWFAdXNlcnMubm9yZXBseS5naXRodWIuY29tPlwiLFwiUGVwaWpuIGRlIFZvcyA8cGVwaWpuZGV2b3NAZ21haWwuY29tPlwiLFwiSm9vWW91bmcgPHFrZGxxbEBuYXZlci5jb20+XCIsXCJUb2JpYXMgU3BlaWNoZXIgPHJvb3Rjb21tYW5kZXJAZ21haWwuY29tPlwiLFwiU3RldmUgQmxhdXJvY2sgPHNibGF1cm9ja0BnbWFpbC5jb20+XCIsXCJLeXJ5bG8gU2hlZ2VkYSA8c2hlZ2VkYUB1YWxiZXJ0YS5jYT5cIixcIkRpd2FuayBTaW5naCBUb21lciA8c2luZ2hAZGl3YW5rLm5hbWU+XCIsXCJTb1xcdTAzMDhyZW4gQmFsa28gPFNvZXJlbi5CYWxrb0BnbWFpbC5jb20+XCIsXCJBcnBpdCBTb2xhbmtpIDxzb2xhbmtpYXJwaXQxOTk3QGdtYWlsLmNvbT5cIixcIll1a2kgSXRvIDx5dWtpQGdubmsubmV0PlwiLFwiQXJ0dXIgWmF5YXRzIDx6YWcyYXJ0QGdtYWlsLmNvbT5cIl0sXCJmdW5kaW5nXCI6e1widHlwZVwiOlwib3BlbmNvbGxlY3RpdmVcIixcInVybFwiOlwiaHR0cHM6Ly9vcGVuY29sbGVjdGl2ZS5jb20vcGVlclwifSxcImNvbGxlY3RpdmVcIjp7XCJ0eXBlXCI6XCJvcGVuY29sbGVjdGl2ZVwiLFwidXJsXCI6XCJodHRwczovL29wZW5jb2xsZWN0aXZlLmNvbS9wZWVyXCJ9LFwiZmlsZXNcIjpbXCJkaXN0LypcIl0sXCJzaWRlRWZmZWN0c1wiOltcImxpYi9nbG9iYWwudHNcIixcImxpYi9zdXBwb3J0cy50c1wiXSxcIm1haW5cIjpcImRpc3QvYnVuZGxlci5janNcIixcIm1vZHVsZVwiOlwiZGlzdC9idW5kbGVyLm1qc1wiLFwiYnJvd3Nlci1taW5pZmllZFwiOlwiZGlzdC9wZWVyanMubWluLmpzXCIsXCJicm93c2VyLXVubWluaWZpZWRcIjpcImRpc3QvcGVlcmpzLmpzXCIsXCJicm93c2VyLW1pbmlmaWVkLW1zZ3BhY2tcIjpcImRpc3Qvc2VyaWFsaXplci5tc2dwYWNrLm1qc1wiLFwidHlwZXNcIjpcImRpc3QvdHlwZXMuZC50c1wiLFwiZW5naW5lc1wiOntcIm5vZGVcIjpcIj49IDE0XCJ9LFwidGFyZ2V0c1wiOntcInR5cGVzXCI6e1wic291cmNlXCI6XCJsaWIvZXhwb3J0cy50c1wifSxcIm1haW5cIjp7XCJzb3VyY2VcIjpcImxpYi9leHBvcnRzLnRzXCIsXCJzb3VyY2VNYXBcIjp7XCJpbmxpbmVTb3VyY2VzXCI6dHJ1ZX19LFwibW9kdWxlXCI6e1wic291cmNlXCI6XCJsaWIvZXhwb3J0cy50c1wiLFwiaW5jbHVkZU5vZGVNb2R1bGVzXCI6W1wiZXZlbnRlbWl0dGVyM1wiXSxcInNvdXJjZU1hcFwiOntcImlubGluZVNvdXJjZXNcIjp0cnVlfX0sXCJicm93c2VyLW1pbmlmaWVkXCI6e1wiY29udGV4dFwiOlwiYnJvd3NlclwiLFwib3V0cHV0Rm9ybWF0XCI6XCJnbG9iYWxcIixcIm9wdGltaXplXCI6dHJ1ZSxcImVuZ2luZXNcIjp7XCJicm93c2Vyc1wiOlwiY2hyb21lID49IDgzLCBlZGdlID49IDgzLCBmaXJlZm94ID49IDgwLCBzYWZhcmkgPj0gMTVcIn0sXCJzb3VyY2VcIjpcImxpYi9nbG9iYWwudHNcIn0sXCJicm93c2VyLXVubWluaWZpZWRcIjp7XCJjb250ZXh0XCI6XCJicm93c2VyXCIsXCJvdXRwdXRGb3JtYXRcIjpcImdsb2JhbFwiLFwib3B0aW1pemVcIjpmYWxzZSxcImVuZ2luZXNcIjp7XCJicm93c2Vyc1wiOlwiY2hyb21lID49IDgzLCBlZGdlID49IDgzLCBmaXJlZm94ID49IDgwLCBzYWZhcmkgPj0gMTVcIn0sXCJzb3VyY2VcIjpcImxpYi9nbG9iYWwudHNcIn0sXCJicm93c2VyLW1pbmlmaWVkLW1zZ3BhY2tcIjp7XCJjb250ZXh0XCI6XCJicm93c2VyXCIsXCJvdXRwdXRGb3JtYXRcIjpcImVzbW9kdWxlXCIsXCJpc0xpYnJhcnlcIjp0cnVlLFwib3B0aW1pemVcIjp0cnVlLFwiZW5naW5lc1wiOntcImJyb3dzZXJzXCI6XCJjaHJvbWUgPj0gODMsIGVkZ2UgPj0gODMsIGZpcmVmb3ggPj0gMTAyLCBzYWZhcmkgPj0gMTVcIn0sXCJzb3VyY2VcIjpcImxpYi9kYXRhY29ubmVjdGlvbi9TdHJlYW1Db25uZWN0aW9uL01zZ1BhY2sudHNcIn19LFwic2NyaXB0c1wiOntcImNvbnRyaWJ1dG9yc1wiOlwiZ2l0LWF1dGhvcnMtY2xpIC0tcHJpbnQ9ZmFsc2UgJiYgcHJldHRpZXIgLS13cml0ZSBwYWNrYWdlLmpzb24gJiYgZ2l0IGFkZCBwYWNrYWdlLmpzb24gcGFja2FnZS1sb2NrLmpzb24gJiYgZ2l0IGNvbW1pdCAtbSBcXFxcXCJjaG9yZShjb250cmlidXRvcnMpOiB1cGRhdGUgYW5kIHNvcnQgY29udHJpYnV0b3JzIGxpc3RcXFxcXCJcIixcImNoZWNrXCI6XCJ0c2MgLS1ub0VtaXQgJiYgdHNjIC1wIGUyZS90c2NvbmZpZy5qc29uIC0tbm9FbWl0XCIsXCJ3YXRjaFwiOlwicGFyY2VsIHdhdGNoXCIsXCJidWlsZFwiOlwicm0gLXJmIGRpc3QgJiYgcGFyY2VsIGJ1aWxkXCIsXCJwcmVwdWJsaXNoT25seVwiOlwibnBtIHJ1biBidWlsZFwiLFwidGVzdFwiOlwiamVzdFwiLFwidGVzdDp3YXRjaFwiOlwiamVzdCAtLXdhdGNoXCIsXCJjb3ZlcmFnZVwiOlwiamVzdCAtLWNvdmVyYWdlIC0tY29sbGVjdENvdmVyYWdlRnJvbT1cXFxcXCIuL2xpYi8qKlxcXFxcIlwiLFwiZm9ybWF0XCI6XCJwcmV0dGllciAtLXdyaXRlIC5cIixcImZvcm1hdDpjaGVja1wiOlwicHJldHRpZXIgLS1jaGVjayAuXCIsXCJzZW1hbnRpYy1yZWxlYXNlXCI6XCJzZW1hbnRpYy1yZWxlYXNlXCIsXCJlMmVcIjpcIndkaW8gcnVuIGUyZS93ZGlvLmxvY2FsLmNvbmYudHNcIixcImUyZTpic3RhY2tcIjpcIndkaW8gcnVuIGUyZS93ZGlvLmJzdGFjay5jb25mLnRzXCJ9LFwiZGV2RGVwZW5kZW5jaWVzXCI6e1wiQHBhcmNlbC9jb25maWctZGVmYXVsdFwiOlwiXjIuOS4zXCIsXCJAcGFyY2VsL3BhY2thZ2VyLXRzXCI6XCJeMi45LjNcIixcIkBwYXJjZWwvdHJhbnNmb3JtZXItdHlwZXNjcmlwdC10c2NcIjpcIl4yLjkuM1wiLFwiQHBhcmNlbC90cmFuc2Zvcm1lci10eXBlc2NyaXB0LXR5cGVzXCI6XCJeMi45LjNcIixcIkBzZW1hbnRpYy1yZWxlYXNlL2NoYW5nZWxvZ1wiOlwiXjYuMC4xXCIsXCJAc2VtYW50aWMtcmVsZWFzZS9naXRcIjpcIl4xMC4wLjFcIixcIkBzd2MvY29yZVwiOlwiXjEuMy4yN1wiLFwiQHN3Yy9qZXN0XCI6XCJeMC4yLjI0XCIsXCJAdHlwZXMvamFzbWluZVwiOlwiXjQuMy40XCIsXCJAd2Rpby9icm93c2Vyc3RhY2stc2VydmljZVwiOlwiXjguMTEuMlwiLFwiQHdkaW8vY2xpXCI6XCJeOC4xMS4yXCIsXCJAd2Rpby9nbG9iYWxzXCI6XCJeOC4xMS4yXCIsXCJAd2Rpby9qYXNtaW5lLWZyYW1ld29ya1wiOlwiXjguMTEuMlwiLFwiQHdkaW8vbG9jYWwtcnVubmVyXCI6XCJeOC4xMS4yXCIsXCJAd2Rpby9zcGVjLXJlcG9ydGVyXCI6XCJeOC4xMS4yXCIsXCJAd2Rpby90eXBlc1wiOlwiXjguMTAuNFwiLFwiaHR0cC1zZXJ2ZXJcIjpcIl4xNC4xLjFcIixcImplc3RcIjpcIl4yOS4zLjFcIixcImplc3QtZW52aXJvbm1lbnQtanNkb21cIjpcIl4yOS4zLjFcIixcIm1vY2stc29ja2V0XCI6XCJeOS4wLjBcIixcInBhcmNlbFwiOlwiXjIuOS4zXCIsXCJwcmV0dGllclwiOlwiXjMuMC4wXCIsXCJzZW1hbnRpYy1yZWxlYXNlXCI6XCJeMjEuMC4wXCIsXCJ0cy1ub2RlXCI6XCJeMTAuOS4xXCIsXCJ0eXBlc2NyaXB0XCI6XCJeNS4wLjBcIixcIndkaW8tZ2Vja29kcml2ZXItc2VydmljZVwiOlwiXjUuMC4xXCJ9LFwiZGVwZW5kZW5jaWVzXCI6e1wiQG1zZ3BhY2svbXNncGFja1wiOlwiXjIuOC4wXCIsXCJldmVudGVtaXR0ZXIzXCI6XCJeNC4wLjdcIixcInBlZXJqcy1qcy1iaW5hcnlwYWNrXCI6XCJeMi4xLjBcIixcIndlYnJ0Yy1hZGFwdGVyXCI6XCJeOS4wLjBcIn0sXCJhbGlhc1wiOntcInByb2Nlc3NcIjpmYWxzZSxcImJ1ZmZlclwiOmZhbHNlfX0nKTtcblxuXG5jbGFzcyAkOGY1YmZhNjA4MzZkMjYxZCRleHBvcnQkNDc5ODkxN2RiZjE0OWI3OSBleHRlbmRzICgwLCAkYzRkY2ZkMWQxZWE4NjY0NyRleHBvcnRzLkV2ZW50RW1pdHRlcikge1xuICAgIGNvbnN0cnVjdG9yKHNlY3VyZSwgaG9zdCwgcG9ydCwgcGF0aCwga2V5LCBwaW5nSW50ZXJ2YWwgPSA1MDAwKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5waW5nSW50ZXJ2YWwgPSBwaW5nSW50ZXJ2YWw7XG4gICAgICAgIHRoaXMuX2Rpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VzUXVldWUgPSBbXTtcbiAgICAgICAgY29uc3Qgd3NQcm90b2NvbCA9IHNlY3VyZSA/IFwid3NzOi8vXCIgOiBcIndzOi8vXCI7XG4gICAgICAgIHRoaXMuX2Jhc2VVcmwgPSB3c1Byb3RvY29sICsgaG9zdCArIFwiOlwiICsgcG9ydCArIHBhdGggKyBcInBlZXJqcz9rZXk9XCIgKyBrZXk7XG4gICAgfVxuICAgIHN0YXJ0KGlkLCB0b2tlbikge1xuICAgICAgICB0aGlzLl9pZCA9IGlkO1xuICAgICAgICBjb25zdCB3c1VybCA9IGAke3RoaXMuX2Jhc2VVcmx9JmlkPSR7aWR9JnRva2VuPSR7dG9rZW59YDtcbiAgICAgICAgaWYgKCEhdGhpcy5fc29ja2V0IHx8ICF0aGlzLl9kaXNjb25uZWN0ZWQpIHJldHVybjtcbiAgICAgICAgdGhpcy5fc29ja2V0ID0gbmV3IFdlYlNvY2tldCh3c1VybCArIFwiJnZlcnNpb249XCIgKyAoMCwgJGY1Zjg4MWVjNDU3NWYxZmMkZXhwb3J0cy52ZXJzaW9uKSk7XG4gICAgICAgIHRoaXMuX2Rpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zb2NrZXQub25tZXNzYWdlID0gKGV2ZW50KT0+e1xuICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJTZXJ2ZXIgbWVzc2FnZSByZWNlaXZlZDpcIiwgZGF0YSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhcIkludmFsaWQgc2VydmVyIG1lc3NhZ2VcIiwgZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkM2I1YzRhNGI2MzU0ZjAyMykuTWVzc2FnZSwgZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NvY2tldC5vbmNsb3NlID0gKGV2ZW50KT0+e1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Rpc2Nvbm5lY3RlZCkgcmV0dXJuO1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhcIlNvY2tldCBjbG9zZWQuXCIsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVtaXQoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzYjVjNGE0YjYzNTRmMDIzKS5EaXNjb25uZWN0ZWQpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBUYWtlIGNhcmUgb2YgdGhlIHF1ZXVlIG9mIGNvbm5lY3Rpb25zIGlmIG5lY2Vzc2FyeSBhbmQgbWFrZSBzdXJlIFBlZXIga25vd3NcbiAgICAgICAgLy8gc29ja2V0IGlzIG9wZW4uXG4gICAgICAgIHRoaXMuX3NvY2tldC5vbm9wZW4gPSAoKT0+e1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Rpc2Nvbm5lY3RlZCkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5fc2VuZFF1ZXVlZE1lc3NhZ2VzKCk7XG4gICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiU29ja2V0IG9wZW5cIik7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZUhlYXJ0YmVhdCgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBfc2NoZWR1bGVIZWFydGJlYXQoKSB7XG4gICAgICAgIHRoaXMuX3dzUGluZ1RpbWVyID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgdGhpcy5fc2VuZEhlYXJ0YmVhdCgpO1xuICAgICAgICB9LCB0aGlzLnBpbmdJbnRlcnZhbCk7XG4gICAgfVxuICAgIF9zZW5kSGVhcnRiZWF0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3dzT3BlbigpKSB7XG4gICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBDYW5ub3Qgc2VuZCBoZWFydGJlYXQsIGJlY2F1c2Ugc29ja2V0IGNsb3NlZGApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICB0eXBlOiAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JGFkYjRhMTc1NGRhNmYxMGQpLkhlYXJ0YmVhdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc29ja2V0LnNlbmQobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlSGVhcnRiZWF0KCk7XG4gICAgfVxuICAgIC8qKiBJcyB0aGUgd2Vic29ja2V0IGN1cnJlbnRseSBvcGVuPyAqLyBfd3NPcGVuKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9zb2NrZXQgJiYgdGhpcy5fc29ja2V0LnJlYWR5U3RhdGUgPT09IDE7XG4gICAgfVxuICAgIC8qKiBTZW5kIHF1ZXVlZCBtZXNzYWdlcy4gKi8gX3NlbmRRdWV1ZWRNZXNzYWdlcygpIHtcbiAgICAgICAgLy9DcmVhdGUgY29weSBvZiBxdWV1ZSBhbmQgY2xlYXIgaXQsXG4gICAgICAgIC8vYmVjYXVzZSBzZW5kIG1ldGhvZCBwdXNoIHRoZSBtZXNzYWdlIGJhY2sgdG8gcXVldWUgaWYgc210aCB3aWxsIGdvIHdyb25nXG4gICAgICAgIGNvbnN0IGNvcGllZFF1ZXVlID0gW1xuICAgICAgICAgICAgLi4udGhpcy5fbWVzc2FnZXNRdWV1ZVxuICAgICAgICBdO1xuICAgICAgICB0aGlzLl9tZXNzYWdlc1F1ZXVlID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBjb3BpZWRRdWV1ZSl0aGlzLnNlbmQobWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKiBFeHBvc2VkIHNlbmQgZm9yIERDICYgUGVlci4gKi8gc2VuZChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXNjb25uZWN0ZWQpIHJldHVybjtcbiAgICAgICAgLy8gSWYgd2UgZGlkbid0IGdldCBhbiBJRCB5ZXQsIHdlIGNhbid0IHlldCBzZW5kIGFueXRoaW5nIHNvIHdlIHNob3VsZCBxdWV1ZVxuICAgICAgICAvLyB1cCB0aGVzZSBtZXNzYWdlcy5cbiAgICAgICAgaWYgKCF0aGlzLl9pZCkge1xuICAgICAgICAgICAgdGhpcy5fbWVzc2FnZXNRdWV1ZS5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YS50eXBlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzYjVjNGE0YjYzNTRmMDIzKS5FcnJvciwgXCJJbnZhbGlkIG1lc3NhZ2VcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl93c09wZW4oKSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgIHRoaXMuX3NvY2tldC5zZW5kKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc2Nvbm5lY3RlZCkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgIHRoaXMuX2Rpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgfVxuICAgIF9jbGVhbnVwKCkge1xuICAgICAgICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9zb2NrZXQub25vcGVuID0gdGhpcy5fc29ja2V0Lm9ubWVzc2FnZSA9IHRoaXMuX3NvY2tldC5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3NvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5fc29ja2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl93c1BpbmdUaW1lcik7XG4gICAgfVxufVxuXG5cblxuXG5cblxuY2xhc3MgJGI4MmZiOGZjMDUxNGJmYzEkZXhwb3J0JDg5ZTZiYjVhZDY0YmY0YSB7XG4gICAgY29uc3RydWN0b3IoY29ubmVjdGlvbil7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgUGVlckNvbm5lY3Rpb24gb2JqZWN0IHNldCB1cCBjb3JyZWN0bHkgKGZvciBkYXRhLCBtZWRpYSkuICovIHN0YXJ0Q29ubmVjdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBlZXJDb25uZWN0aW9uID0gdGhpcy5fc3RhcnRQZWVyQ29ubmVjdGlvbigpO1xuICAgICAgICAvLyBTZXQgdGhlIGNvbm5lY3Rpb24ncyBQQy5cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLnBlZXJDb25uZWN0aW9uID0gcGVlckNvbm5lY3Rpb247XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24udHlwZSA9PT0gKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzMTU3ZDU3YjQxMzVlM2JjKS5NZWRpYSAmJiBvcHRpb25zLl9zdHJlYW0pIHRoaXMuX2FkZFRyYWNrc1RvQ29ubmVjdGlvbihvcHRpb25zLl9zdHJlYW0sIHBlZXJDb25uZWN0aW9uKTtcbiAgICAgICAgLy8gV2hhdCBkbyB3ZSBuZWVkIHRvIGRvIG5vdz9cbiAgICAgICAgaWYgKG9wdGlvbnMub3JpZ2luYXRvcikge1xuICAgICAgICAgICAgY29uc3QgZGF0YUNvbm5lY3Rpb24gPSB0aGlzLmNvbm5lY3Rpb247XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgb3JkZXJlZDogISFvcHRpb25zLnJlbGlhYmxlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSBwZWVyQ29ubmVjdGlvbi5jcmVhdGVEYXRhQ2hhbm5lbChkYXRhQ29ubmVjdGlvbi5sYWJlbCwgY29uZmlnKTtcbiAgICAgICAgICAgIGRhdGFDb25uZWN0aW9uLl9pbml0aWFsaXplRGF0YUNoYW5uZWwoZGF0YUNoYW5uZWwpO1xuICAgICAgICAgICAgdGhpcy5fbWFrZU9mZmVyKCk7XG4gICAgICAgIH0gZWxzZSB0aGlzLmhhbmRsZVNEUChcIk9GRkVSXCIsIG9wdGlvbnMuc2RwKTtcbiAgICB9XG4gICAgLyoqIFN0YXJ0IGEgUEMuICovIF9zdGFydFBlZXJDb25uZWN0aW9uKCkge1xuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiQ3JlYXRpbmcgUlRDUGVlckNvbm5lY3Rpb24uXCIpO1xuICAgICAgICBjb25zdCBwZWVyQ29ubmVjdGlvbiA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih0aGlzLmNvbm5lY3Rpb24ucHJvdmlkZXIub3B0aW9ucy5jb25maWcpO1xuICAgICAgICB0aGlzLl9zZXR1cExpc3RlbmVycyhwZWVyQ29ubmVjdGlvbik7XG4gICAgICAgIHJldHVybiBwZWVyQ29ubmVjdGlvbjtcbiAgICB9XG4gICAgLyoqIFNldCB1cCB2YXJpb3VzIFdlYlJUQyBsaXN0ZW5lcnMuICovIF9zZXR1cExpc3RlbmVycyhwZWVyQ29ubmVjdGlvbikge1xuICAgICAgICBjb25zdCBwZWVySWQgPSB0aGlzLmNvbm5lY3Rpb24ucGVlcjtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbklkID0gdGhpcy5jb25uZWN0aW9uLmNvbm5lY3Rpb25JZDtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvblR5cGUgPSB0aGlzLmNvbm5lY3Rpb24udHlwZTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmNvbm5lY3Rpb24ucHJvdmlkZXI7XG4gICAgICAgIC8vIElDRSBDQU5ESURBVEVTLlxuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiTGlzdGVuaW5nIGZvciBJQ0UgY2FuZGlkYXRlcy5cIik7XG4gICAgICAgIHBlZXJDb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlID0gKGV2dCk9PntcbiAgICAgICAgICAgIGlmICghZXZ0LmNhbmRpZGF0ZSB8fCAhZXZ0LmNhbmRpZGF0ZS5jYW5kaWRhdGUpIHJldHVybjtcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coYFJlY2VpdmVkIElDRSBjYW5kaWRhdGVzIGZvciAke3BlZXJJZH06YCwgZXZ0LmNhbmRpZGF0ZSk7XG4gICAgICAgICAgICBwcm92aWRlci5zb2NrZXQuc2VuZCh7XG4gICAgICAgICAgICAgICAgdHlwZTogKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCRhZGI0YTE3NTRkYTZmMTBkKS5DYW5kaWRhdGUsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGU6IGV2dC5jYW5kaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGNvbm5lY3Rpb25UeXBlLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uSWQ6IGNvbm5lY3Rpb25JZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZHN0OiBwZWVySWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBwZWVyQ29ubmVjdGlvbi5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9ICgpPT57XG4gICAgICAgICAgICBzd2l0Y2gocGVlckNvbm5lY3Rpb24uaWNlQ29ubmVjdGlvblN0YXRlKXtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbGVkXCI6XG4gICAgICAgICAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJpY2VDb25uZWN0aW9uU3RhdGUgaXMgZmFpbGVkLCBjbG9zaW5nIGNvbm5lY3Rpb25zIHRvIFwiICsgcGVlcklkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmVtaXRFcnJvcigoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDc5NzQ5MzU2ODYxNDk2ODYpLk5lZ290aWF0aW9uRmFpbGVkLCBcIk5lZ290aWF0aW9uIG9mIGNvbm5lY3Rpb24gdG8gXCIgKyBwZWVySWQgKyBcIiBmYWlsZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNsb3NlZFwiOlxuICAgICAgICAgICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiaWNlQ29ubmVjdGlvblN0YXRlIGlzIGNsb3NlZCwgY2xvc2luZyBjb25uZWN0aW9ucyB0byBcIiArIHBlZXJJZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5lbWl0RXJyb3IoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ3OTc0OTM1Njg2MTQ5Njg2KS5Db25uZWN0aW9uQ2xvc2VkLCBcIkNvbm5lY3Rpb24gdG8gXCIgKyBwZWVySWQgKyBcIiBjbG9zZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRpc2Nvbm5lY3RlZFwiOlxuICAgICAgICAgICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiaWNlQ29ubmVjdGlvblN0YXRlIGNoYW5nZWQgdG8gZGlzY29ubmVjdGVkIG9uIHRoZSBjb25uZWN0aW9uIHdpdGggXCIgKyBwZWVySWQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29tcGxldGVkXCI6XG4gICAgICAgICAgICAgICAgICAgIHBlZXJDb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlID0gKCk9Pnt9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5lbWl0KFwiaWNlU3RhdGVDaGFuZ2VkXCIsIHBlZXJDb25uZWN0aW9uLmljZUNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIERBVEFDT05ORUNUSU9OLlxuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiTGlzdGVuaW5nIGZvciBkYXRhIGNoYW5uZWxcIik7XG4gICAgICAgIC8vIEZpcmVkIGJldHdlZW4gb2ZmZXIgYW5kIGFuc3dlciwgc28gb3B0aW9ucyBzaG91bGQgYWxyZWFkeSBiZSBzYXZlZFxuICAgICAgICAvLyBpbiB0aGUgb3B0aW9ucyBoYXNoLlxuICAgICAgICBwZWVyQ29ubmVjdGlvbi5vbmRhdGFjaGFubmVsID0gKGV2dCk9PntcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJSZWNlaXZlZCBkYXRhIGNoYW5uZWxcIik7XG4gICAgICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IGV2dC5jaGFubmVsO1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHByb3ZpZGVyLmdldENvbm5lY3Rpb24ocGVlcklkLCBjb25uZWN0aW9uSWQpO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5faW5pdGlhbGl6ZURhdGFDaGFubmVsKGRhdGFDaGFubmVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTUVESUFDT05ORUNUSU9OLlxuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiTGlzdGVuaW5nIGZvciByZW1vdGUgc3RyZWFtXCIpO1xuICAgICAgICBwZWVyQ29ubmVjdGlvbi5vbnRyYWNrID0gKGV2dCk9PntcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJSZWNlaXZlZCByZW1vdGUgc3RyZWFtXCIpO1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gZXZ0LnN0cmVhbXNbMF07XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gcHJvdmlkZXIuZ2V0Q29ubmVjdGlvbihwZWVySWQsIGNvbm5lY3Rpb25JZCk7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbi50eXBlID09PSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDMxNTdkNTdiNDEzNWUzYmMpLk1lZGlhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVkaWFDb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRTdHJlYW1Ub01lZGlhQ29ubmVjdGlvbihzdHJlYW0sIG1lZGlhQ29ubmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJDbGVhbmluZyB1cCBQZWVyQ29ubmVjdGlvbiB0byBcIiArIHRoaXMuY29ubmVjdGlvbi5wZWVyKTtcbiAgICAgICAgY29uc3QgcGVlckNvbm5lY3Rpb24gPSB0aGlzLmNvbm5lY3Rpb24ucGVlckNvbm5lY3Rpb247XG4gICAgICAgIGlmICghcGVlckNvbm5lY3Rpb24pIHJldHVybjtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLnBlZXJDb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgLy91bnN1YnNjcmliZSBmcm9tIGFsbCBQZWVyQ29ubmVjdGlvbidzIGV2ZW50c1xuICAgICAgICBwZWVyQ29ubmVjdGlvbi5vbmljZWNhbmRpZGF0ZSA9IHBlZXJDb25uZWN0aW9uLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gcGVlckNvbm5lY3Rpb24ub25kYXRhY2hhbm5lbCA9IHBlZXJDb25uZWN0aW9uLm9udHJhY2sgPSAoKT0+e307XG4gICAgICAgIGNvbnN0IHBlZXJDb25uZWN0aW9uTm90Q2xvc2VkID0gcGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUgIT09IFwiY2xvc2VkXCI7XG4gICAgICAgIGxldCBkYXRhQ2hhbm5lbE5vdENsb3NlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuY29ubmVjdGlvbi5kYXRhQ2hhbm5lbDtcbiAgICAgICAgaWYgKGRhdGFDaGFubmVsKSBkYXRhQ2hhbm5lbE5vdENsb3NlZCA9ICEhZGF0YUNoYW5uZWwucmVhZHlTdGF0ZSAmJiBkYXRhQ2hhbm5lbC5yZWFkeVN0YXRlICE9PSBcImNsb3NlZFwiO1xuICAgICAgICBpZiAocGVlckNvbm5lY3Rpb25Ob3RDbG9zZWQgfHwgZGF0YUNoYW5uZWxOb3RDbG9zZWQpIHBlZXJDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgfVxuICAgIGFzeW5jIF9tYWtlT2ZmZXIoKSB7XG4gICAgICAgIGNvbnN0IHBlZXJDb25uZWN0aW9uID0gdGhpcy5jb25uZWN0aW9uLnBlZXJDb25uZWN0aW9uO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuY29ubmVjdGlvbi5wcm92aWRlcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgcGVlckNvbm5lY3Rpb24uY3JlYXRlT2ZmZXIodGhpcy5jb25uZWN0aW9uLm9wdGlvbnMuY29uc3RyYWludHMpO1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhcIkNyZWF0ZWQgb2ZmZXIuXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbi5vcHRpb25zLnNkcFRyYW5zZm9ybSAmJiB0eXBlb2YgdGhpcy5jb25uZWN0aW9uLm9wdGlvbnMuc2RwVHJhbnNmb3JtID09PSBcImZ1bmN0aW9uXCIpIG9mZmVyLnNkcCA9IHRoaXMuY29ubmVjdGlvbi5vcHRpb25zLnNkcFRyYW5zZm9ybShvZmZlci5zZHApIHx8IG9mZmVyLnNkcDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcGVlckNvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhcIlNldCBsb2NhbERlc2NyaXB0aW9uOlwiLCBvZmZlciwgYGZvcjoke3RoaXMuY29ubmVjdGlvbi5wZWVyfWApO1xuICAgICAgICAgICAgICAgIGxldCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICBzZHA6IG9mZmVyLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLmNvbm5lY3Rpb24udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbklkOiB0aGlzLmNvbm5lY3Rpb24uY29ubmVjdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogdGhpcy5jb25uZWN0aW9uLm1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uLnR5cGUgPT09ICgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkMzE1N2Q1N2I0MTM1ZTNiYykuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhQ29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZGF0YUNvbm5lY3Rpb24ubGFiZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWxpYWJsZTogZGF0YUNvbm5lY3Rpb24ucmVsaWFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemF0aW9uOiBkYXRhQ29ubmVjdGlvbi5zZXJpYWxpemF0aW9uXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnNvY2tldC5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCRhZGI0YTE3NTRkYTZmMTBkKS5PZmZlcixcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgZHN0OiB0aGlzLmNvbm5lY3Rpb24ucGVlclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgd2h5IF9tYWtlT2ZmZXIgaXMgYmVpbmcgY2FsbGVkIGZyb20gdGhlIGFuc3dlclxuICAgICAgICAgICAgICAgIGlmIChlcnIgIT0gXCJPcGVyYXRpb25FcnJvcjogRmFpbGVkIHRvIHNldCBsb2NhbCBvZmZlciBzZHA6IENhbGxlZCBpbiB3cm9uZyBzdGF0ZToga0hhdmVSZW1vdGVPZmZlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLmVtaXRFcnJvcigoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpLldlYlJUQywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhcIkZhaWxlZCB0byBzZXRMb2NhbERlc2NyaXB0aW9uLCBcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycl8xKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0RXJyb3IoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmKS5XZWJSVEMsIGVycl8xKTtcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJGYWlsZWQgdG8gY3JlYXRlT2ZmZXIsIFwiLCBlcnJfMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX21ha2VBbnN3ZXIoKSB7XG4gICAgICAgIGNvbnN0IHBlZXJDb25uZWN0aW9uID0gdGhpcy5jb25uZWN0aW9uLnBlZXJDb25uZWN0aW9uO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuY29ubmVjdGlvbi5wcm92aWRlcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHBlZXJDb25uZWN0aW9uLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhcIkNyZWF0ZWQgYW5zd2VyLlwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24ub3B0aW9ucy5zZHBUcmFuc2Zvcm0gJiYgdHlwZW9mIHRoaXMuY29ubmVjdGlvbi5vcHRpb25zLnNkcFRyYW5zZm9ybSA9PT0gXCJmdW5jdGlvblwiKSBhbnN3ZXIuc2RwID0gdGhpcy5jb25uZWN0aW9uLm9wdGlvbnMuc2RwVHJhbnNmb3JtKGFuc3dlci5zZHApIHx8IGFuc3dlci5zZHA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHBlZXJDb25uZWN0aW9uLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBTZXQgbG9jYWxEZXNjcmlwdGlvbjpgLCBhbnN3ZXIsIGBmb3I6JHt0aGlzLmNvbm5lY3Rpb24ucGVlcn1gKTtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5zb2NrZXQuc2VuZCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkYWRiNGExNzU0ZGE2ZjEwZCkuQW5zd2VyLFxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZHA6IGFuc3dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMuY29ubmVjdGlvbi50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbklkOiB0aGlzLmNvbm5lY3Rpb24uY29ubmVjdGlvbklkXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRzdDogdGhpcy5jb25uZWN0aW9uLnBlZXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLmVtaXRFcnJvcigoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpLldlYlJUQywgZXJyKTtcbiAgICAgICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiRmFpbGVkIHRvIHNldExvY2FsRGVzY3JpcHRpb24sIFwiLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJfMSkge1xuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdEVycm9yKCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkOTU0N2FhYTJlMzkwMzBmZikuV2ViUlRDLCBlcnJfMSk7XG4gICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiRmFpbGVkIHRvIGNyZWF0ZSBhbnN3ZXIsIFwiLCBlcnJfMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEhhbmRsZSBhbiBTRFAuICovIGFzeW5jIGhhbmRsZVNEUCh0eXBlLCBzZHApIHtcbiAgICAgICAgc2RwID0gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbihzZHApO1xuICAgICAgICBjb25zdCBwZWVyQ29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbi5wZWVyQ29ubmVjdGlvbjtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmNvbm5lY3Rpb24ucHJvdmlkZXI7XG4gICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJTZXR0aW5nIHJlbW90ZSBkZXNjcmlwdGlvblwiLCBzZHApO1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHBlZXJDb25uZWN0aW9uLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkcCk7XG4gICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBTZXQgcmVtb3RlRGVzY3JpcHRpb246JHt0eXBlfSBmb3I6JHt0aGlzLmNvbm5lY3Rpb24ucGVlcn1gKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIk9GRkVSXCIpIGF3YWl0IHNlbGYuX21ha2VBbnN3ZXIoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0RXJyb3IoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmKS5XZWJSVEMsIGVycik7XG4gICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiRmFpbGVkIHRvIHNldFJlbW90ZURlc2NyaXB0aW9uLCBcIiwgZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogSGFuZGxlIGEgY2FuZGlkYXRlLiAqLyBhc3luYyBoYW5kbGVDYW5kaWRhdGUoaWNlKSB7XG4gICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coYGhhbmRsZUNhbmRpZGF0ZTpgLCBpY2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLnBlZXJDb25uZWN0aW9uLmFkZEljZUNhbmRpZGF0ZShpY2UpO1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhgQWRkZWQgSUNFIGNhbmRpZGF0ZSBmb3I6JHt0aGlzLmNvbm5lY3Rpb24ucGVlcn1gKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24ucHJvdmlkZXIuZW1pdEVycm9yKCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkOTU0N2FhYTJlMzkwMzBmZikuV2ViUlRDLCBlcnIpO1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhcIkZhaWxlZCB0byBoYW5kbGVDYW5kaWRhdGUsIFwiLCBlcnIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hZGRUcmFja3NUb0Nvbm5lY3Rpb24oc3RyZWFtLCBwZWVyQ29ubmVjdGlvbikge1xuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBhZGQgdHJhY2tzIGZyb20gc3RyZWFtICR7c3RyZWFtLmlkfSB0byBwZWVyIGNvbm5lY3Rpb25gKTtcbiAgICAgICAgaWYgKCFwZWVyQ29ubmVjdGlvbi5hZGRUcmFjaykgcmV0dXJuICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5lcnJvcihgWW91ciBicm93c2VyIGRvZXMndCBzdXBwb3J0IFJUQ1BlZXJDb25uZWN0aW9uI2FkZFRyYWNrLiBJZ25vcmVkLmApO1xuICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCgodHJhY2spPT57XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5hZGRUcmFjayh0cmFjaywgc3RyZWFtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRTdHJlYW1Ub01lZGlhQ29ubmVjdGlvbihzdHJlYW0sIG1lZGlhQ29ubmVjdGlvbikge1xuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBhZGQgc3RyZWFtICR7c3RyZWFtLmlkfSB0byBtZWRpYSBjb25uZWN0aW9uICR7bWVkaWFDb25uZWN0aW9uLmNvbm5lY3Rpb25JZH1gKTtcbiAgICAgICAgbWVkaWFDb25uZWN0aW9uLmFkZFN0cmVhbShzdHJlYW0pO1xuICAgIH1cbn1cblxuXG5cblxuXG5jbGFzcyAkMjM3NzlkMTg4MTE1N2ExOCRleHBvcnQkNmE2NzhlNTg5YzhhNDU0MiBleHRlbmRzICgwLCAkYzRkY2ZkMWQxZWE4NjY0NyRleHBvcnRzLkV2ZW50RW1pdHRlcikge1xuICAgIC8qKlxuXHQgKiBFbWl0cyBhIHR5cGVkIGVycm9yIG1lc3NhZ2UuXG5cdCAqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKi8gZW1pdEVycm9yKHR5cGUsIGVycikge1xuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkuZXJyb3IoXCJFcnJvcjpcIiwgZXJyKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBuZXcgJDIzNzc5ZDE4ODExNTdhMTgkZXhwb3J0JDk4ODcxODgyZjQ5MmRlODIoYCR7dHlwZX1gLCBlcnIpKTtcbiAgICB9XG59XG5jbGFzcyAkMjM3NzlkMTg4MTE1N2ExOCRleHBvcnQkOTg4NzE4ODJmNDkyZGU4MiBleHRlbmRzIEVycm9yIHtcbiAgICAvKipcblx0ICogQGludGVybmFsXG5cdCAqLyBjb25zdHJ1Y3Rvcih0eXBlLCBlcnIpe1xuICAgICAgICBpZiAodHlwZW9mIGVyciA9PT0gXCJzdHJpbmdcIikgc3VwZXIoZXJyKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxufVxuXG5cbmNsYXNzICQ1MDQ1MTkyZmM2ZDM4N2JhJGV4cG9ydCQyM2EyYTY4MjgzYzI0ZDgwIGV4dGVuZHMgKDAsICQyMzc3OWQxODgxMTU3YTE4JGV4cG9ydCQ2YTY3OGU1ODljOGE0NTQyKSB7XG4gICAgLyoqXG5cdCAqIFdoZXRoZXIgdGhlIG1lZGlhIGNvbm5lY3Rpb24gaXMgYWN0aXZlIChlLmcuIHlvdXIgY2FsbCBoYXMgYmVlbiBhbnN3ZXJlZCkuXG5cdCAqIFlvdSBjYW4gY2hlY2sgdGhpcyBpZiB5b3Ugd2FudCB0byBzZXQgYSBtYXhpbXVtIHdhaXQgdGltZSBmb3IgYSBvbmUtc2lkZWQgY2FsbC5cblx0ICovIGdldCBvcGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3BlbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLyoqXG5cdFx0ICogVGhlIElEIG9mIHRoZSBwZWVyIG9uIHRoZSBvdGhlciBlbmQgb2YgdGhpcyBjb25uZWN0aW9uLlxuXHRcdCAqLyBwZWVyLCBwcm92aWRlciwgb3B0aW9ucyl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucGVlciA9IHBlZXI7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fb3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gb3B0aW9ucy5tZXRhZGF0YTtcbiAgICB9XG59XG5cblxuY2xhc3MgJDVjMWQwOGM3YzU3ZGE5YTMkZXhwb3J0JDRhODRlOTVhMjMyNGFjMjkgZXh0ZW5kcyAoMCwgJDUwNDUxOTJmYzZkMzg3YmEkZXhwb3J0JDIzYTJhNjgyODNjMjRkODApIHtcbiAgICBzdGF0aWMgI18gPSB0aGlzLklEX1BSRUZJWCA9IFwibWNfXCI7XG4gICAgLyoqXG5cdCAqIEZvciBtZWRpYSBjb25uZWN0aW9ucywgdGhpcyBpcyBhbHdheXMgJ21lZGlhJy5cblx0ICovIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzMTU3ZDU3YjQxMzVlM2JjKS5NZWRpYTtcbiAgICB9XG4gICAgZ2V0IGxvY2FsU3RyZWFtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxTdHJlYW07XG4gICAgfVxuICAgIGdldCByZW1vdGVTdHJlYW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdGVTdHJlYW07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHBlZXJJZCwgcHJvdmlkZXIsIG9wdGlvbnMpe1xuICAgICAgICBzdXBlcihwZWVySWQsIHByb3ZpZGVyLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW0gPSB0aGlzLm9wdGlvbnMuX3N0cmVhbTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uSWQgPSB0aGlzLm9wdGlvbnMuY29ubmVjdGlvbklkIHx8ICQ1YzFkMDhjN2M1N2RhOWEzJGV4cG9ydCQ0YTg0ZTk1YTIzMjRhYzI5LklEX1BSRUZJWCArICgwLCAkNGY0MTM0MTU2YzQ0NjM5MiRleHBvcnQkN2RlYmI1MGVmMTFkNWUwYikucmFuZG9tVG9rZW4oKTtcbiAgICAgICAgdGhpcy5fbmVnb3RpYXRvciA9IG5ldyAoMCwgJGI4MmZiOGZjMDUxNGJmYzEkZXhwb3J0JDg5ZTZiYjVhZDY0YmY0YSkodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLl9sb2NhbFN0cmVhbSkgdGhpcy5fbmVnb3RpYXRvci5zdGFydENvbm5lY3Rpb24oe1xuICAgICAgICAgICAgX3N0cmVhbTogdGhpcy5fbG9jYWxTdHJlYW0sXG4gICAgICAgICAgICBvcmlnaW5hdG9yOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQ2FsbGVkIGJ5IHRoZSBOZWdvdGlhdG9yIHdoZW4gdGhlIERhdGFDaGFubmVsIGlzIHJlYWR5LiAqLyBfaW5pdGlhbGl6ZURhdGFDaGFubmVsKGRjKSB7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWwgPSBkYztcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5vbm9wZW4gPSAoKT0+e1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhgREMjJHt0aGlzLmNvbm5lY3Rpb25JZH0gZGMgY29ubmVjdGlvbiBzdWNjZXNzYCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJ3aWxsQ2xvc2VPblJlbW90ZVwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5vbmNsb3NlID0gKCk9PntcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coYERDIyR7dGhpcy5jb25uZWN0aW9uSWR9IGRjIGNsb3NlZCBmb3I6YCwgdGhpcy5wZWVyKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYWRkU3RyZWFtKHJlbW90ZVN0cmVhbSkge1xuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiUmVjZWl2aW5nIHN0cmVhbVwiLCByZW1vdGVTdHJlYW0pO1xuICAgICAgICB0aGlzLl9yZW1vdGVTdHJlYW0gPSByZW1vdGVTdHJlYW07XG4gICAgICAgIHN1cGVyLmVtaXQoXCJzdHJlYW1cIiwgcmVtb3RlU3RyZWFtKTsgLy8gU2hvdWxkIHdlIGNhbGwgdGhpcyBgb3BlbmA/XG4gICAgfVxuICAgIC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICovIGhhbmRsZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS50eXBlO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gbWVzc2FnZS5wYXlsb2FkO1xuICAgICAgICBzd2l0Y2gobWVzc2FnZS50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCRhZGI0YTE3NTRkYTZmMTBkKS5BbnN3ZXI6XG4gICAgICAgICAgICAgICAgLy8gRm9yd2FyZCB0byBuZWdvdGlhdG9yXG4gICAgICAgICAgICAgICAgdGhpcy5fbmVnb3RpYXRvci5oYW5kbGVTRFAodHlwZSwgcGF5bG9hZC5zZHApO1xuICAgICAgICAgICAgICAgIHRoaXMuX29wZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JGFkYjRhMTc1NGRhNmYxMGQpLkNhbmRpZGF0ZTpcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWdvdGlhdG9yLmhhbmRsZUNhbmRpZGF0ZShwYXlsb2FkLmNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS53YXJuKGBVbnJlY29nbml6ZWQgbWVzc2FnZSB0eXBlOiR7dHlwZX0gZnJvbSBwZWVyOiR7dGhpcy5wZWVyfWApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gcmVjZWl2aW5nIGEge0BhcGlsaW5rIFBlZXJFdmVudHMgfCBgY2FsbGB9IGV2ZW50IG9uIGEgcGVlciwgeW91IGNhbiBjYWxsXG4gICAgICogYGFuc3dlcmAgb24gdGhlIG1lZGlhIGNvbm5lY3Rpb24gcHJvdmlkZWQgYnkgdGhlIGNhbGxiYWNrIHRvIGFjY2VwdCB0aGUgY2FsbFxuICAgICAqIGFuZCBvcHRpb25hbGx5IHNlbmQgeW91ciBvd24gbWVkaWEgc3RyZWFtLlxuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RyZWFtIEEgV2ViUlRDIG1lZGlhIHN0cmVhbS5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovIGFuc3dlcihzdHJlYW0sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAodGhpcy5fbG9jYWxTdHJlYW0pIHtcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS53YXJuKFwiTG9jYWwgc3RyZWFtIGFscmVhZHkgZXhpc3RzIG9uIHRoaXMgTWVkaWFDb25uZWN0aW9uLiBBcmUgeW91IGFuc3dlcmluZyBhIGNhbGwgdHdpY2U/XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtID0gc3RyZWFtO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNkcFRyYW5zZm9ybSkgdGhpcy5vcHRpb25zLnNkcFRyYW5zZm9ybSA9IG9wdGlvbnMuc2RwVHJhbnNmb3JtO1xuICAgICAgICB0aGlzLl9uZWdvdGlhdG9yLnN0YXJ0Q29ubmVjdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMuX3BheWxvYWQsXG4gICAgICAgICAgICBfc3RyZWFtOiBzdHJlYW1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJldHJpZXZlIGxvc3QgbWVzc2FnZXMgc3RvcmVkIGJlY2F1c2UgUGVlckNvbm5lY3Rpb24gbm90IHNldCB1cC5cbiAgICAgICAgY29uc3QgbWVzc2FnZXMgPSB0aGlzLnByb3ZpZGVyLl9nZXRNZXNzYWdlcyh0aGlzLmNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcyl0aGlzLmhhbmRsZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuX29wZW4gPSB0cnVlO1xuICAgIH1cbiAgICAvKipcblx0ICogRXhwb3NlZCBmdW5jdGlvbmFsaXR5IGZvciB1c2Vycy5cblx0ICovIC8qKlxuXHQgKiBDbG9zZXMgdGhlIG1lZGlhIGNvbm5lY3Rpb24uXG5cdCAqLyBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX25lZ290aWF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX25lZ290aWF0b3IuY2xlYW51cCgpO1xuICAgICAgICAgICAgdGhpcy5fbmVnb3RpYXRvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW0gPSBudWxsO1xuICAgICAgICB0aGlzLl9yZW1vdGVTdHJlYW0gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlci5fcmVtb3ZlQ29ubmVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLl9zdHJlYW0pIHRoaXMub3B0aW9ucy5fc3RyZWFtID0gbnVsbDtcbiAgICAgICAgaWYgKCF0aGlzLm9wZW4pIHJldHVybjtcbiAgICAgICAgdGhpcy5fb3BlbiA9IGZhbHNlO1xuICAgICAgICBzdXBlci5lbWl0KFwiY2xvc2VcIik7XG4gICAgfVxufVxuXG5cblxuXG5cblxuY2xhc3MgJGFiZjI2NjY0MTkyN2NkODkkZXhwb3J0JDJjNGU4MjVkYzkxMjBmODcge1xuICAgIGNvbnN0cnVjdG9yKF9vcHRpb25zKXtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9vcHRpb25zO1xuICAgIH1cbiAgICBfYnVpbGRSZXF1ZXN0KG1ldGhvZCkge1xuICAgICAgICBjb25zdCBwcm90b2NvbCA9IHRoaXMuX29wdGlvbnMuc2VjdXJlID8gXCJodHRwc1wiIDogXCJodHRwXCI7XG4gICAgICAgIGNvbnN0IHsgaG9zdDogaG9zdCwgcG9ydDogcG9ydCwgcGF0aDogcGF0aCwga2V5OiBrZXkgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7cHJvdG9jb2x9Oi8vJHtob3N0fToke3BvcnR9JHtwYXRofSR7a2V5fS8ke21ldGhvZH1gKTtcbiAgICAgICAgLy8gVE9ETzogV2h5IHRpbWVzdGFtcCwgd2h5IHJhbmRvbT9cbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ0c1wiLCBgJHtEYXRlLm5vdygpfSR7TWF0aC5yYW5kb20oKX1gKTtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ2ZXJzaW9uXCIsICgwLCAkZjVmODgxZWM0NTc1ZjFmYyRleHBvcnRzLnZlcnNpb24pKTtcbiAgICAgICAgcmV0dXJuIGZldGNoKHVybC5ocmVmLCB7XG4gICAgICAgICAgICByZWZlcnJlclBvbGljeTogdGhpcy5fb3B0aW9ucy5yZWZlcnJlclBvbGljeVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEdldCBhIHVuaXF1ZSBJRCBmcm9tIHRoZSBzZXJ2ZXIgdmlhIFhIUiBhbmQgaW5pdGlhbGl6ZSB3aXRoIGl0LiAqLyBhc3luYyByZXRyaWV2ZUlkKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9idWlsZFJlcXVlc3QoXCJpZFwiKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkgdGhyb3cgbmV3IEVycm9yKGBFcnJvci4gU3RhdHVzOiR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5lcnJvcihcIkVycm9yIHJldHJpZXZpbmcgSURcIiwgZXJyb3IpO1xuICAgICAgICAgICAgbGV0IHBhdGhFcnJvciA9IFwiXCI7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5wYXRoID09PSBcIi9cIiAmJiB0aGlzLl9vcHRpb25zLmhvc3QgIT09ICgwLCAkNGY0MTM0MTU2YzQ0NjM5MiRleHBvcnQkN2RlYmI1MGVmMTFkNWUwYikuQ0xPVURfSE9TVCkgcGF0aEVycm9yID0gXCIgSWYgeW91IHBhc3NlZCBpbiBhIGBwYXRoYCB0byB5b3VyIHNlbGYtaG9zdGVkIFBlZXJTZXJ2ZXIsIHlvdSdsbCBhbHNvIG5lZWQgdG8gcGFzcyBpbiB0aGF0IHNhbWUgcGF0aCB3aGVuIGNyZWF0aW5nIGEgbmV3IFBlZXIuXCI7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IGFuIElEIGZyb20gdGhlIHNlcnZlci5cIiArIHBhdGhFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovIGFzeW5jIGxpc3RBbGxQZWVycygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fYnVpbGRSZXF1ZXN0KFwicGVlcnNcIik7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhlbHBmdWxFcnJvciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmhvc3QgPT09ICgwLCAkNGY0MTM0MTU2YzQ0NjM5MiRleHBvcnQkN2RlYmI1MGVmMTFkNWUwYikuQ0xPVURfSE9TVCkgaGVscGZ1bEVycm9yID0gXCJJdCBsb29rcyBsaWtlIHlvdSdyZSB1c2luZyB0aGUgY2xvdWQgc2VydmVyLiBZb3UgY2FuIGVtYWlsIHRlYW1AcGVlcmpzLmNvbSB0byBlbmFibGUgcGVlciBsaXN0aW5nIGZvciB5b3VyIEFQSSBrZXkuXCI7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaGVscGZ1bEVycm9yID0gXCJZb3UgbmVlZCB0byBlbmFibGUgYGFsbG93X2Rpc2NvdmVyeWAgb24geW91ciBzZWxmLWhvc3RlZCBQZWVyU2VydmVyIHRvIHVzZSB0aGlzIGZlYXR1cmUuXCI7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkl0IGRvZXNuJ3QgbG9vayBsaWtlIHlvdSBoYXZlIHBlcm1pc3Npb24gdG8gbGlzdCBwZWVycyBJRHMuIFwiICsgaGVscGZ1bEVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvci4gU3RhdHVzOiR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5lcnJvcihcIkVycm9yIHJldHJpZXZpbmcgbGlzdCBwZWVyc1wiLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IGxpc3QgcGVlcnMgZnJvbSB0aGUgc2VydmVyLlwiICsgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuXG5cblxuXG5cblxuXG5jbGFzcyAkNjM2NmM0Y2ExNjFiYzI5NyRleHBvcnQkZDM2NWY3YWQ5ZDdkZjljOSBleHRlbmRzICgwLCAkNTA0NTE5MmZjNmQzODdiYSRleHBvcnQkMjNhMmE2ODI4M2MyNGQ4MCkge1xuICAgIHN0YXRpYyAjXyA9IHRoaXMuSURfUFJFRklYID0gXCJkY19cIjtcbiAgICBzdGF0aWMgI18yID0gdGhpcy5NQVhfQlVGRkVSRURfQU1PVU5UID0gODM4ODYwODtcbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkMzE1N2Q1N2I0MTM1ZTNiYykuRGF0YTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocGVlcklkLCBwcm92aWRlciwgb3B0aW9ucyl7XG4gICAgICAgIHN1cGVyKHBlZXJJZCwgcHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25JZCA9IHRoaXMub3B0aW9ucy5jb25uZWN0aW9uSWQgfHwgJDYzNjZjNGNhMTYxYmMyOTckZXhwb3J0JGQzNjVmN2FkOWQ3ZGY5YzkuSURfUFJFRklYICsgKDAsICQwZTVmZDE1ODU3ODRjMjUyJGV4cG9ydCQ0ZTYxZjY3MjkzNmJlYzc3KSgpO1xuICAgICAgICB0aGlzLmxhYmVsID0gdGhpcy5vcHRpb25zLmxhYmVsIHx8IHRoaXMuY29ubmVjdGlvbklkO1xuICAgICAgICB0aGlzLnJlbGlhYmxlID0gISF0aGlzLm9wdGlvbnMucmVsaWFibGU7XG4gICAgICAgIHRoaXMuX25lZ290aWF0b3IgPSBuZXcgKDAsICRiODJmYjhmYzA1MTRiZmMxJGV4cG9ydCQ4OWU2YmI1YWQ2NGJmNGEpKHRoaXMpO1xuICAgICAgICB0aGlzLl9uZWdvdGlhdG9yLnN0YXJ0Q29ubmVjdGlvbih0aGlzLm9wdGlvbnMuX3BheWxvYWQgfHwge1xuICAgICAgICAgICAgb3JpZ2luYXRvcjogdHJ1ZSxcbiAgICAgICAgICAgIHJlbGlhYmxlOiB0aGlzLnJlbGlhYmxlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQ2FsbGVkIGJ5IHRoZSBOZWdvdGlhdG9yIHdoZW4gdGhlIERhdGFDaGFubmVsIGlzIHJlYWR5LiAqLyBfaW5pdGlhbGl6ZURhdGFDaGFubmVsKGRjKSB7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWwgPSBkYztcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5vbm9wZW4gPSAoKT0+e1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhgREMjJHt0aGlzLmNvbm5lY3Rpb25JZH0gZGMgY29ubmVjdGlvbiBzdWNjZXNzYCk7XG4gICAgICAgICAgICB0aGlzLl9vcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcIm9wZW5cIik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWwub25tZXNzYWdlID0gKGUpPT57XG4gICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBEQyMke3RoaXMuY29ubmVjdGlvbklkfSBkYyBvbm1lc3NhZ2U6YCwgZS5kYXRhKTtcbiAgICAgICAgLy8gdGhpcy5faGFuZGxlRGF0YU1lc3NhZ2UoZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWwub25jbG9zZSA9ICgpPT57XG4gICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBEQyMke3RoaXMuY29ubmVjdGlvbklkfSBkYyBjbG9zZWQgZm9yOmAsIHRoaXMucGVlcik7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuXHQgKiBFeHBvc2VkIGZ1bmN0aW9uYWxpdHkgZm9yIHVzZXJzLlxuXHQgKi8gLyoqIEFsbG93cyB1c2VyIHRvIGNsb3NlIGNvbm5lY3Rpb24uICovIGNsb3NlKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnM/LmZsdXNoKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgICAgIF9fcGVlckRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjbG9zZVwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX25lZ290aWF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX25lZ290aWF0b3IuY2xlYW51cCgpO1xuICAgICAgICAgICAgdGhpcy5fbmVnb3RpYXRvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIuX3JlbW92ZUNvbm5lY3Rpb24odGhpcyk7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRhQ2hhbm5lbCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5vbm9wZW4gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5uZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcGVuKSByZXR1cm47XG4gICAgICAgIHRoaXMuX29wZW4gPSBmYWxzZTtcbiAgICAgICAgc3VwZXIuZW1pdChcImNsb3NlXCIpO1xuICAgIH1cbiAgICAvKiogQWxsb3dzIHVzZXIgdG8gc2VuZCBkYXRhLiAqLyBzZW5kKGRhdGEsIGNodW5rZWQgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMub3Blbikge1xuICAgICAgICAgICAgdGhpcy5lbWl0RXJyb3IoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ0OWFlODAwYzExNGRmNDFkKS5Ob3RPcGVuWWV0LCBcIkNvbm5lY3Rpb24gaXMgbm90IG9wZW4uIFlvdSBzaG91bGQgbGlzdGVuIGZvciB0aGUgYG9wZW5gIGV2ZW50IGJlZm9yZSBzZW5kaW5nIG1lc3NhZ2VzLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2VuZChkYXRhLCBjaHVua2VkKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBtZXNzYWdlLnBheWxvYWQ7XG4gICAgICAgIHN3aXRjaChtZXNzYWdlLnR5cGUpe1xuICAgICAgICAgICAgY2FzZSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JGFkYjRhMTc1NGRhNmYxMGQpLkFuc3dlcjpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9uZWdvdGlhdG9yLmhhbmRsZVNEUChtZXNzYWdlLnR5cGUsIHBheWxvYWQuc2RwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCRhZGI0YTE3NTRkYTZmMTBkKS5DYW5kaWRhdGU6XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbmVnb3RpYXRvci5oYW5kbGVDYW5kaWRhdGUocGF5bG9hZC5jYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkud2FybihcIlVucmVjb2duaXplZCBtZXNzYWdlIHR5cGU6XCIsIG1lc3NhZ2UudHlwZSwgXCJmcm9tIHBlZXI6XCIsIHRoaXMucGVlcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuY2xhc3MgJGEyMjliZWRiY2FhNmNhMjMkZXhwb3J0JGZmN2M5ZDRjMTFkOTRlOGIgZXh0ZW5kcyAoMCwgJDYzNjZjNGNhMTYxYmMyOTckZXhwb3J0JGQzNjVmN2FkOWQ3ZGY5YzkpIHtcbiAgICBnZXQgYnVmZmVyU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlclNpemU7XG4gICAgfVxuICAgIF9pbml0aWFsaXplRGF0YUNoYW5uZWwoZGMpIHtcbiAgICAgICAgc3VwZXIuX2luaXRpYWxpemVEYXRhQ2hhbm5lbChkYyk7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWwuYmluYXJ5VHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZSk9PnRoaXMuX2hhbmRsZURhdGFNZXNzYWdlKGUpKTtcbiAgICB9XG4gICAgX2J1ZmZlcmVkU2VuZChtc2cpIHtcbiAgICAgICAgaWYgKHRoaXMuX2J1ZmZlcmluZyB8fCAhdGhpcy5fdHJ5U2VuZChtc2cpKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXIucHVzaChtc2cpO1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyU2l6ZSA9IHRoaXMuX2J1ZmZlci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBzZW5kIHN1Y2NlZWRzLlxuICAgIF90cnlTZW5kKG1zZykge1xuICAgICAgICBpZiAoIXRoaXMub3BlbikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5kYXRhQ2hhbm5lbC5idWZmZXJlZEFtb3VudCA+ICgwLCAkNjM2NmM0Y2ExNjFiYzI5NyRleHBvcnQkZDM2NWY3YWQ5ZDdkZjljOSkuTUFYX0JVRkZFUkVEX0FNT1VOVCkge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl90cnlCdWZmZXIoKTtcbiAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5zZW5kKG1zZyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5lcnJvcihgREMjOiR7dGhpcy5jb25uZWN0aW9uSWR9IEVycm9yIHdoZW4gc2VuZGluZzpgLCBlKTtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlcmluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFRyeSB0byBzZW5kIHRoZSBmaXJzdCBtZXNzYWdlIGluIHRoZSBidWZmZXIuXG4gICAgX3RyeUJ1ZmZlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wZW4pIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuX2J1ZmZlci5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICAgY29uc3QgbXNnID0gdGhpcy5fYnVmZmVyWzBdO1xuICAgICAgICBpZiAodGhpcy5fdHJ5U2VuZChtc2cpKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXIuc2hpZnQoKTtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclNpemUgPSB0aGlzLl9idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fdHJ5QnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2Uob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucz8uZmx1c2gpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZCh7XG4gICAgICAgICAgICAgICAgX19wZWVyRGF0YToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNsb3NlXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5fYnVmZmVyU2l6ZSA9IDA7XG4gICAgICAgIHN1cGVyLmNsb3NlKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy5fYnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuX2J1ZmZlclNpemUgPSAwO1xuICAgICAgICB0aGlzLl9idWZmZXJpbmcgPSBmYWxzZTtcbiAgICB9XG59XG5cblxuXG5cbmNsYXNzICQ5ZmNmZGRiM2FlMTQ4Zjg4JGV4cG9ydCRmMGE1YTY0ZDViYjM3MTA4IGV4dGVuZHMgKDAsICRhMjI5YmVkYmNhYTZjYTIzJGV4cG9ydCRmZjdjOWQ0YzExZDk0ZThiKSB7XG4gICAgY2xvc2Uob3B0aW9ucykge1xuICAgICAgICBzdXBlci5jbG9zZShvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fY2h1bmtlZERhdGEgPSB7fTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocGVlcklkLCBwcm92aWRlciwgb3B0aW9ucyl7XG4gICAgICAgIHN1cGVyKHBlZXJJZCwgcHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNodW5rZXIgPSBuZXcgKDAsICRmY2JjYzc1MzhhNjc3NmQ1JGV4cG9ydCRmMWM1ZjRjOWNiOTUzOTBiKSgpO1xuICAgICAgICB0aGlzLnNlcmlhbGl6YXRpb24gPSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDg5ZjUwN2NmOTg2YTk0NykuQmluYXJ5O1xuICAgICAgICB0aGlzLl9jaHVua2VkRGF0YSA9IHt9O1xuICAgIH1cbiAgICAvLyBIYW5kbGVzIGEgRGF0YUNoYW5uZWwgbWVzc2FnZS5cbiAgICBfaGFuZGxlRGF0YU1lc3NhZ2UoeyBkYXRhOiBkYXRhIH0pIHtcbiAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkRGF0YSA9ICgwLCAkZ0NjYlkkdW5wYWNrKShkYXRhKTtcbiAgICAgICAgLy8gUGVlckpTIHNwZWNpZmljIG1lc3NhZ2VcbiAgICAgICAgY29uc3QgcGVlckRhdGEgPSBkZXNlcmlhbGl6ZWREYXRhW1wiX19wZWVyRGF0YVwiXTtcbiAgICAgICAgaWYgKHBlZXJEYXRhKSB7XG4gICAgICAgICAgICBpZiAocGVlckRhdGEudHlwZSA9PT0gXCJjbG9zZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENodW5rZWQgZGF0YSAtLSBwaWVjZSB0aGluZ3MgYmFjayB0b2dldGhlci5cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUNodW5rKGRlc2VyaWFsaXplZERhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgZGVzZXJpYWxpemVkRGF0YSk7XG4gICAgfVxuICAgIF9oYW5kbGVDaHVuayhkYXRhKSB7XG4gICAgICAgIGNvbnN0IGlkID0gZGF0YS5fX3BlZXJEYXRhO1xuICAgICAgICBjb25zdCBjaHVua0luZm8gPSB0aGlzLl9jaHVua2VkRGF0YVtpZF0gfHwge1xuICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgIHRvdGFsOiBkYXRhLnRvdGFsXG4gICAgICAgIH07XG4gICAgICAgIGNodW5rSW5mby5kYXRhW2RhdGEubl0gPSBuZXcgVWludDhBcnJheShkYXRhLmRhdGEpO1xuICAgICAgICBjaHVua0luZm8uY291bnQrKztcbiAgICAgICAgdGhpcy5fY2h1bmtlZERhdGFbaWRdID0gY2h1bmtJbmZvO1xuICAgICAgICBpZiAoY2h1bmtJbmZvLnRvdGFsID09PSBjaHVua0luZm8uY291bnQpIHtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGJlZm9yZSBtYWtpbmcgdGhlIHJlY3Vyc2l2ZSBjYWxsIHRvIGBfaGFuZGxlRGF0YU1lc3NhZ2VgLlxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NodW5rZWREYXRhW2lkXTtcbiAgICAgICAgICAgIC8vIFdlJ3ZlIHJlY2VpdmVkIGFsbCB0aGUgY2h1bmtzLS10aW1lIHRvIGNvbnN0cnVjdCB0aGUgY29tcGxldGUgZGF0YS5cbiAgICAgICAgICAgIC8vIGNvbnN0IGRhdGEgPSBuZXcgQmxvYihjaHVua0luZm8uZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gKDAsICRmY2JjYzc1MzhhNjc3NmQ1JGV4cG9ydCQ1MmM4OWViY2RjNGY1M2YyKShjaHVua0luZm8uZGF0YSk7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVEYXRhTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3NlbmQoZGF0YSwgY2h1bmtlZCkge1xuICAgICAgICBjb25zdCBibG9iID0gKDAsICRnQ2NiWSRwYWNrKShkYXRhKTtcbiAgICAgICAgaWYgKGJsb2IgaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gdGhpcy5fc2VuZF9ibG9iKGJsb2IpO1xuICAgICAgICBpZiAoIWNodW5rZWQgJiYgYmxvYi5ieXRlTGVuZ3RoID4gdGhpcy5jaHVua2VyLmNodW5rZWRNVFUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRDaHVua3MoYmxvYik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYnVmZmVyZWRTZW5kKGJsb2IpO1xuICAgIH1cbiAgICBhc3luYyBfc2VuZF9ibG9iKGJsb2JQcm9taXNlKSB7XG4gICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBibG9iUHJvbWlzZTtcbiAgICAgICAgaWYgKGJsb2IuYnl0ZUxlbmd0aCA+IHRoaXMuY2h1bmtlci5jaHVua2VkTVRVKSB7XG4gICAgICAgICAgICB0aGlzLl9zZW5kQ2h1bmtzKGJsb2IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2J1ZmZlcmVkU2VuZChibG9iKTtcbiAgICB9XG4gICAgX3NlbmRDaHVua3MoYmxvYikge1xuICAgICAgICBjb25zdCBibG9icyA9IHRoaXMuY2h1bmtlci5jaHVuayhibG9iKTtcbiAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhgREMjJHt0aGlzLmNvbm5lY3Rpb25JZH0gVHJ5IHRvIHNlbmQgJHtibG9icy5sZW5ndGh9IGNodW5rcy4uLmApO1xuICAgICAgICBmb3IgKGNvbnN0IGJsb2Igb2YgYmxvYnMpdGhpcy5zZW5kKGJsb2IsIHRydWUpO1xuICAgIH1cbn1cblxuXG5cblxuY2xhc3MgJGJiYWVlM2YxNWY3MTQ2NjMkZXhwb3J0JDZmODhmZTQ3ZDMyYzljOTQgZXh0ZW5kcyAoMCwgJGEyMjliZWRiY2FhNmNhMjMkZXhwb3J0JGZmN2M5ZDRjMTFkOTRlOGIpIHtcbiAgICBfaGFuZGxlRGF0YU1lc3NhZ2UoeyBkYXRhOiBkYXRhIH0pIHtcbiAgICAgICAgc3VwZXIuZW1pdChcImRhdGFcIiwgZGF0YSk7XG4gICAgfVxuICAgIF9zZW5kKGRhdGEsIF9jaHVua2VkKSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlcmVkU2VuZChkYXRhKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnNlcmlhbGl6YXRpb24gPSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDg5ZjUwN2NmOTg2YTk0NykuTm9uZTtcbiAgICB9XG59XG5cblxuXG5cblxuY2xhc3MgJDgxN2Y5MzFlM2Y5MDk2Y2YkZXhwb3J0JDQ4ODgwYWM2MzVmNDcxODYgZXh0ZW5kcyAoMCwgJGEyMjliZWRiY2FhNmNhMjMkZXhwb3J0JGZmN2M5ZDRjMTFkOTRlOGIpIHtcbiAgICAvLyBIYW5kbGVzIGEgRGF0YUNoYW5uZWwgbWVzc2FnZS5cbiAgICBfaGFuZGxlRGF0YU1lc3NhZ2UoeyBkYXRhOiBkYXRhIH0pIHtcbiAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkRGF0YSA9IHRoaXMucGFyc2UodGhpcy5kZWNvZGVyLmRlY29kZShkYXRhKSk7XG4gICAgICAgIC8vIFBlZXJKUyBzcGVjaWZpYyBtZXNzYWdlXG4gICAgICAgIGNvbnN0IHBlZXJEYXRhID0gZGVzZXJpYWxpemVkRGF0YVtcIl9fcGVlckRhdGFcIl07XG4gICAgICAgIGlmIChwZWVyRGF0YSAmJiBwZWVyRGF0YS50eXBlID09PSBcImNsb3NlXCIpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJkYXRhXCIsIGRlc2VyaWFsaXplZERhdGEpO1xuICAgIH1cbiAgICBfc2VuZChkYXRhLCBfY2h1bmtlZCkge1xuICAgICAgICBjb25zdCBlbmNvZGVkRGF0YSA9IHRoaXMuZW5jb2Rlci5lbmNvZGUodGhpcy5zdHJpbmdpZnkoZGF0YSkpO1xuICAgICAgICBpZiAoZW5jb2RlZERhdGEuYnl0ZUxlbmd0aCA+PSAoMCwgJDRmNDEzNDE1NmM0NDYzOTIkZXhwb3J0JDdkZWJiNTBlZjExZDVlMGIpLmNodW5rZWRNVFUpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdEVycm9yKCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkNDlhZTgwMGMxMTRkZjQxZCkuTWVzc2FnZVRvQmlnLCBcIk1lc3NhZ2UgdG9vIGJpZyBmb3IgSlNPTiBjaGFubmVsXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2J1ZmZlcmVkU2VuZChlbmNvZGVkRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemF0aW9uID0gKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ4OWY1MDdjZjk4NmE5NDcpLkpTT047XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICB0aGlzLmRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgICAgdGhpcy5zdHJpbmdpZnkgPSBKU09OLnN0cmluZ2lmeTtcbiAgICAgICAgdGhpcy5wYXJzZSA9IEpTT04ucGFyc2U7XG4gICAgfVxufVxuXG5cblxuY2xhc3MgJDQxNjI2MGJjZTMzN2RmOTAkdmFyJFBlZXJPcHRpb25zIHtcbn1cbmNsYXNzICQ0MTYyNjBiY2UzMzdkZjkwJGV4cG9ydCRlY2QxZmMxMzZjNDIyNDQ4IGV4dGVuZHMgKDAsICQyMzc3OWQxODgxMTU3YTE4JGV4cG9ydCQ2YTY3OGU1ODljOGE0NTQyKSB7XG4gICAgc3RhdGljICNfID0gdGhpcy5ERUZBVUxUX0tFWSA9IFwicGVlcmpzXCI7XG4gICAgLyoqXG5cdCAqIFRoZSBicm9rZXJpbmcgSUQgb2YgdGhpcyBwZWVyXG5cdCAqXG5cdCAqIElmIG5vIElEIHdhcyBzcGVjaWZpZWQgaW4ge0BhcGlsaW5rIFBlZXIgfCB0aGUgY29uc3RydWN0b3J9LFxuXHQgKiB0aGlzIHdpbGwgYmUgYHVuZGVmaW5lZGAgdW50aWwgdGhlIHtAYXBpbGluayBQZWVyRXZlbnRzIHwgYG9wZW5gfSBldmVudCBpcyBlbWl0dGVkLlxuXHQgKi8gZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgICB9XG4gICAgZ2V0IG9wZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcGVuO1xuICAgIH1cbiAgICAvKipcblx0ICogQGludGVybmFsXG5cdCAqLyBnZXQgc29ja2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc29ja2V0O1xuICAgIH1cbiAgICAvKipcblx0ICogQSBoYXNoIG9mIGFsbCBjb25uZWN0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhpcyBwZWVyLCBrZXllZCBieSB0aGUgcmVtb3RlIHBlZXIncyBJRC5cblx0ICogQGRlcHJlY2F0ZWRcblx0ICogUmV0dXJuIHR5cGUgd2lsbCBjaGFuZ2UgZnJvbSBPYmplY3QgdG8gTWFwPHN0cmluZyxbXT5cblx0ICovIGdldCBjb25uZWN0aW9ucygpIHtcbiAgICAgICAgY29uc3QgcGxhaW5Db25uZWN0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHRoaXMuX2Nvbm5lY3Rpb25zKXBsYWluQ29ubmVjdGlvbnNba10gPSB2O1xuICAgICAgICByZXR1cm4gcGxhaW5Db25uZWN0aW9ucztcbiAgICB9XG4gICAgLyoqXG5cdCAqIHRydWUgaWYgdGhpcyBwZWVyIGFuZCBhbGwgb2YgaXRzIGNvbm5lY3Rpb25zIGNhbiBubyBsb25nZXIgYmUgdXNlZC5cblx0ICovIGdldCBkZXN0cm95ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXN0cm95ZWQ7XG4gICAgfVxuICAgIC8qKlxuXHQgKiBmYWxzZSBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgY29ubmVjdGlvbiB0byB0aGUgUGVlclNlcnZlci5cblx0ICovIGdldCBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNjb25uZWN0ZWQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlkLCBvcHRpb25zKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fc2VyaWFsaXplcnMgPSB7XG4gICAgICAgICAgICByYXc6ICgwLCAkYmJhZWUzZjE1ZjcxNDY2MyRleHBvcnQkNmY4OGZlNDdkMzJjOWM5NCksXG4gICAgICAgICAgICBqc29uOiAoMCwgJDgxN2Y5MzFlM2Y5MDk2Y2YkZXhwb3J0JDQ4ODgwYWM2MzVmNDcxODYpLFxuICAgICAgICAgICAgYmluYXJ5OiAoMCwgJDlmY2ZkZGIzYWUxNDhmODgkZXhwb3J0JGYwYTVhNjRkNWJiMzcxMDgpLFxuICAgICAgICAgICAgXCJiaW5hcnktdXRmOFwiOiAoMCwgJDlmY2ZkZGIzYWUxNDhmODgkZXhwb3J0JGYwYTVhNjRkNWJiMzcxMDgpLFxuICAgICAgICAgICAgZGVmYXVsdDogKDAsICQ5ZmNmZGRiM2FlMTQ4Zjg4JGV4cG9ydCRmMGE1YTY0ZDViYjM3MTA4KVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9pZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xhc3RTZXJ2ZXJJZCA9IG51bGw7XG4gICAgICAgIC8vIFN0YXRlcy5cbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2UgLy8gQ29ubmVjdGlvbnMgaGF2ZSBiZWVuIGtpbGxlZFxuICAgICAgICA7XG4gICAgICAgIHRoaXMuX2Rpc2Nvbm5lY3RlZCA9IGZhbHNlIC8vIENvbm5lY3Rpb24gdG8gUGVlclNlcnZlciBraWxsZWQgYnV0IFAyUCBjb25uZWN0aW9ucyBzdGlsbCBhY3RpdmVcbiAgICAgICAgO1xuICAgICAgICB0aGlzLl9vcGVuID0gZmFsc2UgLy8gU29ja2V0cyBhbmQgc3VjaCBhcmUgbm90IHlldCBvcGVuLlxuICAgICAgICA7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25zID0gbmV3IE1hcCgpIC8vIEFsbCBjb25uZWN0aW9ucyBmb3IgdGhpcyBwZWVyLlxuICAgICAgICA7XG4gICAgICAgIHRoaXMuX2xvc3RNZXNzYWdlcyA9IG5ldyBNYXAoKSAvLyBzcmMgPT4gW2xpc3Qgb2YgbWVzc2FnZXNdXG4gICAgICAgIDtcbiAgICAgICAgbGV0IHVzZXJJZDtcbiAgICAgICAgLy8gRGVhbCB3aXRoIG92ZXJsb2FkaW5nXG4gICAgICAgIGlmIChpZCAmJiBpZC5jb25zdHJ1Y3RvciA9PSBPYmplY3QpIG9wdGlvbnMgPSBpZDtcbiAgICAgICAgZWxzZSBpZiAoaWQpIHVzZXJJZCA9IGlkLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIENvbmZpZ3VyaXplIG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGRlYnVnOiAwLFxuICAgICAgICAgICAgaG9zdDogKDAsICQ0ZjQxMzQxNTZjNDQ2MzkyJGV4cG9ydCQ3ZGViYjUwZWYxMWQ1ZTBiKS5DTE9VRF9IT1NULFxuICAgICAgICAgICAgcG9ydDogKDAsICQ0ZjQxMzQxNTZjNDQ2MzkyJGV4cG9ydCQ3ZGViYjUwZWYxMWQ1ZTBiKS5DTE9VRF9QT1JULFxuICAgICAgICAgICAgcGF0aDogXCIvXCIsXG4gICAgICAgICAgICBrZXk6ICQ0MTYyNjBiY2UzMzdkZjkwJGV4cG9ydCRlY2QxZmMxMzZjNDIyNDQ4LkRFRkFVTFRfS0VZLFxuICAgICAgICAgICAgdG9rZW46ICgwLCAkNGY0MTM0MTU2YzQ0NjM5MiRleHBvcnQkN2RlYmI1MGVmMTFkNWUwYikucmFuZG9tVG9rZW4oKSxcbiAgICAgICAgICAgIGNvbmZpZzogKDAsICQ0ZjQxMzQxNTZjNDQ2MzkyJGV4cG9ydCQ3ZGViYjUwZWYxMWQ1ZTBiKS5kZWZhdWx0Q29uZmlnLFxuICAgICAgICAgICAgcmVmZXJyZXJQb2xpY3k6IFwic3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpblwiLFxuICAgICAgICAgICAgc2VyaWFsaXplcnM6IHt9LFxuICAgICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fc2VyaWFsaXplcnMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLl9zZXJpYWxpemVycyxcbiAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy5zZXJpYWxpemVyc1xuICAgICAgICB9O1xuICAgICAgICAvLyBEZXRlY3QgcmVsYXRpdmUgVVJMIGhvc3QuXG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmhvc3QgPT09IFwiL1wiKSB0aGlzLl9vcHRpb25zLmhvc3QgPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG4gICAgICAgIC8vIFNldCBwYXRoIGNvcnJlY3RseS5cbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMucGF0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMucGF0aFswXSAhPT0gXCIvXCIpIHRoaXMuX29wdGlvbnMucGF0aCA9IFwiL1wiICsgdGhpcy5fb3B0aW9ucy5wYXRoO1xuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMucGF0aFt0aGlzLl9vcHRpb25zLnBhdGgubGVuZ3RoIC0gMV0gIT09IFwiL1wiKSB0aGlzLl9vcHRpb25zLnBhdGggKz0gXCIvXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHdoZXRoZXIgd2UgdXNlIFNTTCB0byBzYW1lIGFzIGN1cnJlbnQgaG9zdFxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5zZWN1cmUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9vcHRpb25zLmhvc3QgIT09ICgwLCAkNGY0MTM0MTU2YzQ0NjM5MiRleHBvcnQkN2RlYmI1MGVmMTFkNWUwYikuQ0xPVURfSE9TVCkgdGhpcy5fb3B0aW9ucy5zZWN1cmUgPSAoMCwgJDRmNDEzNDE1NmM0NDYzOTIkZXhwb3J0JDdkZWJiNTBlZjExZDVlMGIpLmlzU2VjdXJlKCk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuaG9zdCA9PSAoMCwgJDRmNDEzNDE1NmM0NDYzOTIkZXhwb3J0JDdkZWJiNTBlZjExZDVlMGIpLkNMT1VEX0hPU1QpIHRoaXMuX29wdGlvbnMuc2VjdXJlID0gdHJ1ZTtcbiAgICAgICAgLy8gU2V0IGEgY3VzdG9tIGxvZyBmdW5jdGlvbiBpZiBwcmVzZW50XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmxvZ0Z1bmN0aW9uKSAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkuc2V0TG9nRnVuY3Rpb24odGhpcy5fb3B0aW9ucy5sb2dGdW5jdGlvbik7XG4gICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2dMZXZlbCA9IHRoaXMuX29wdGlvbnMuZGVidWcgfHwgMDtcbiAgICAgICAgdGhpcy5fYXBpID0gbmV3ICgwLCAkYWJmMjY2NjQxOTI3Y2Q4OSRleHBvcnQkMmM0ZTgyNWRjOTEyMGY4Nykob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3NvY2tldCA9IHRoaXMuX2NyZWF0ZVNlcnZlckNvbm5lY3Rpb24oKTtcbiAgICAgICAgLy8gU2FuaXR5IGNoZWNrc1xuICAgICAgICAvLyBFbnN1cmUgV2ViUlRDIHN1cHBvcnRlZFxuICAgICAgICBpZiAoISgwLCAkNGY0MTM0MTU2YzQ0NjM5MiRleHBvcnQkN2RlYmI1MGVmMTFkNWUwYikuc3VwcG9ydHMuYXVkaW9WaWRlbyAmJiAhKDAsICQ0ZjQxMzQxNTZjNDQ2MzkyJGV4cG9ydCQ3ZGViYjUwZWYxMWQ1ZTBiKS5zdXBwb3J0cy5kYXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWxheWVkQWJvcnQoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmKS5Ccm93c2VySW5jb21wYXRpYmxlLCBcIlRoZSBjdXJyZW50IGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBXZWJSVENcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlIGFscGhhbnVtZXJpYyBpZFxuICAgICAgICBpZiAoISF1c2VySWQgJiYgISgwLCAkNGY0MTM0MTU2YzQ0NjM5MiRleHBvcnQkN2RlYmI1MGVmMTFkNWUwYikudmFsaWRhdGVJZCh1c2VySWQpKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWxheWVkQWJvcnQoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmKS5JbnZhbGlkSUQsIGBJRCBcIiR7dXNlcklkfVwiIGlzIGludmFsaWRgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlcklkKSB0aGlzLl9pbml0aWFsaXplKHVzZXJJZCk7XG4gICAgICAgIGVsc2UgdGhpcy5fYXBpLnJldHJpZXZlSWQoKS50aGVuKChpZCk9PnRoaXMuX2luaXRpYWxpemUoaWQpKS5jYXRjaCgoZXJyb3IpPT50aGlzLl9hYm9ydCgoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpLlNlcnZlckVycm9yLCBlcnJvcikpO1xuICAgIH1cbiAgICBfY3JlYXRlU2VydmVyQ29ubmVjdGlvbigpIHtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gbmV3ICgwLCAkOGY1YmZhNjA4MzZkMjYxZCRleHBvcnQkNDc5ODkxN2RiZjE0OWI3OSkodGhpcy5fb3B0aW9ucy5zZWN1cmUsIHRoaXMuX29wdGlvbnMuaG9zdCwgdGhpcy5fb3B0aW9ucy5wb3J0LCB0aGlzLl9vcHRpb25zLnBhdGgsIHRoaXMuX29wdGlvbnMua2V5LCB0aGlzLl9vcHRpb25zLnBpbmdJbnRlcnZhbCk7XG4gICAgICAgIHNvY2tldC5vbigoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDNiNWM0YTRiNjM1NGYwMjMpLk1lc3NhZ2UsIChkYXRhKT0+e1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlTWVzc2FnZShkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNvY2tldC5vbigoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDNiNWM0YTRiNjM1NGYwMjMpLkVycm9yLCAoZXJyb3IpPT57XG4gICAgICAgICAgICB0aGlzLl9hYm9ydCgoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpLlNvY2tldEVycm9yLCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBzb2NrZXQub24oKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzYjVjNGE0YjYzNTRmMDIzKS5EaXNjb25uZWN0ZWQsICgpPT57XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNjb25uZWN0ZWQpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuZW1pdEVycm9yKCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkOTU0N2FhYTJlMzkwMzBmZikuTmV0d29yaywgXCJMb3N0IGNvbm5lY3Rpb24gdG8gc2VydmVyLlwiKTtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgc29ja2V0Lm9uKCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkM2I1YzRhNGI2MzU0ZjAyMykuQ2xvc2UsICgpPT57XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNjb25uZWN0ZWQpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuX2Fib3J0KCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkOTU0N2FhYTJlMzkwMzBmZikuU29ja2V0Q2xvc2VkLCBcIlVuZGVybHlpbmcgc29ja2V0IGlzIGFscmVhZHkgY2xvc2VkLlwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzb2NrZXQ7XG4gICAgfVxuICAgIC8qKiBJbml0aWFsaXplIGEgY29ubmVjdGlvbiB3aXRoIHRoZSBzZXJ2ZXIuICovIF9pbml0aWFsaXplKGlkKSB7XG4gICAgICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgICAgIHRoaXMuc29ja2V0LnN0YXJ0KGlkLCB0aGlzLl9vcHRpb25zLnRva2VuKTtcbiAgICB9XG4gICAgLyoqIEhhbmRsZXMgbWVzc2FnZXMgZnJvbSB0aGUgc2VydmVyLiAqLyBfaGFuZGxlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLnR5cGU7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBtZXNzYWdlLnBheWxvYWQ7XG4gICAgICAgIGNvbnN0IHBlZXJJZCA9IG1lc3NhZ2Uuc3JjO1xuICAgICAgICBzd2l0Y2godHlwZSl7XG4gICAgICAgICAgICBjYXNlICgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkYWRiNGExNzU0ZGE2ZjEwZCkuT3BlbjpcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0U2VydmVySWQgPSB0aGlzLmlkO1xuICAgICAgICAgICAgICAgIHRoaXMuX29wZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm9wZW5cIiwgdGhpcy5pZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkYWRiNGExNzU0ZGE2ZjEwZCkuRXJyb3I6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWJvcnQoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmKS5TZXJ2ZXJFcnJvciwgcGF5bG9hZC5tc2cpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JGFkYjRhMTc1NGRhNmYxMGQpLklkVGFrZW46XG4gICAgICAgICAgICAgICAgdGhpcy5fYWJvcnQoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmKS5VbmF2YWlsYWJsZUlELCBgSUQgXCIke3RoaXMuaWR9XCIgaXMgdGFrZW5gKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCRhZGI0YTE3NTRkYTZmMTBkKS5JbnZhbGlkS2V5OlxuICAgICAgICAgICAgICAgIHRoaXMuX2Fib3J0KCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkOTU0N2FhYTJlMzkwMzBmZikuSW52YWxpZEtleSwgYEFQSSBLRVkgXCIke3RoaXMuX29wdGlvbnMua2V5fVwiIGlzIGludmFsaWRgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCRhZGI0YTE3NTRkYTZmMTBkKS5MZWF2ZTpcbiAgICAgICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBSZWNlaXZlZCBsZWF2ZSBtZXNzYWdlIGZyb20gJHtwZWVySWR9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cFBlZXIocGVlcklkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9ucy5kZWxldGUocGVlcklkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCRhZGI0YTE3NTRkYTZmMTBkKS5FeHBpcmU6XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0RXJyb3IoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmKS5QZWVyVW5hdmFpbGFibGUsIGBDb3VsZCBub3QgY29ubmVjdCB0byBwZWVyICR7cGVlcklkfWApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JGFkYjRhMTc1NGRhNmYxMGQpLk9mZmVyOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIGNvbnNpZGVyIHN3aXRjaGluZyB0aGlzIHRvIENBTEwvQ09OTkVDVCwgYnV0IHRoaXMgaXMgdGhlIGxlYXN0IGJyZWFraW5nIG9wdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbklkID0gcGF5bG9hZC5jb25uZWN0aW9uSWQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb25uZWN0aW9uID0gdGhpcy5nZXRDb25uZWN0aW9uKHBlZXJJZCwgY29ubmVjdGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS53YXJuKGBPZmZlciByZWNlaXZlZCBmb3IgZXhpc3RpbmcgQ29ubmVjdGlvbiBJRDoke2Nvbm5lY3Rpb25JZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgY29ubmVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBheWxvYWQudHlwZSA9PT0gKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzMTU3ZDU3YjQxMzVlM2JjKS5NZWRpYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVkaWFDb25uZWN0aW9uID0gbmV3ICgwLCAkNWMxZDA4YzdjNTdkYTlhMyRleHBvcnQkNGE4NGU5NWEyMzI0YWMyOSkocGVlcklkLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbklkOiBjb25uZWN0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3BheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHBheWxvYWQubWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbiA9IG1lZGlhQ29ubmVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZENvbm5lY3Rpb24ocGVlcklkLCBjb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImNhbGxcIiwgbWVkaWFDb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXlsb2FkLnR5cGUgPT09ICgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkMzE1N2Q1N2I0MTM1ZTNiYykuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YUNvbm5lY3Rpb24gPSBuZXcgdGhpcy5fc2VyaWFsaXplcnNbcGF5bG9hZC5zZXJpYWxpemF0aW9uXShwZWVySWQsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uSWQ6IGNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogcGF5bG9hZC5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogcGF5bG9hZC5sYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemF0aW9uOiBwYXlsb2FkLnNlcmlhbGl6YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsaWFibGU6IHBheWxvYWQucmVsaWFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbiA9IGRhdGFDb25uZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkQ29ubmVjdGlvbihwZWVySWQsIGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvblwiLCBkYXRhQ29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkud2FybihgUmVjZWl2ZWQgbWFsZm9ybWVkIGNvbm5lY3Rpb24gdHlwZToke3BheWxvYWQudHlwZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIG1lc3NhZ2VzLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlcyA9IHRoaXMuX2dldE1lc3NhZ2VzKGNvbm5lY3Rpb25JZCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcyljb25uZWN0aW9uLmhhbmRsZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS53YXJuKGBZb3UgcmVjZWl2ZWQgYSBtYWxmb3JtZWQgbWVzc2FnZSBmcm9tICR7cGVlcklkfSBvZiB0eXBlICR7dHlwZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uSWQgPSBwYXlsb2FkLmNvbm5lY3Rpb25JZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHRoaXMuZ2V0Q29ubmVjdGlvbihwZWVySWQsIGNvbm5lY3Rpb25JZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uICYmIGNvbm5lY3Rpb24ucGVlckNvbm5lY3Rpb24pIC8vIFBhc3MgaXQgb24uXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uaGFuZGxlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29ubmVjdGlvbklkKSAvLyBTdG9yZSBmb3IgcG9zc2libGUgbGF0ZXIgdXNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3JlTWVzc2FnZShjb25uZWN0aW9uSWQsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS53YXJuKFwiWW91IHJlY2VpdmVkIGFuIHVucmVjb2duaXplZCBtZXNzYWdlOlwiLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBTdG9yZXMgbWVzc2FnZXMgd2l0aG91dCBhIHNldCB1cCBjb25uZWN0aW9uLCB0byBiZSBjbGFpbWVkIGxhdGVyLiAqLyBfc3RvcmVNZXNzYWdlKGNvbm5lY3Rpb25JZCwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvc3RNZXNzYWdlcy5oYXMoY29ubmVjdGlvbklkKSkgdGhpcy5fbG9zdE1lc3NhZ2VzLnNldChjb25uZWN0aW9uSWQsIFtdKTtcbiAgICAgICAgdGhpcy5fbG9zdE1lc3NhZ2VzLmdldChjb25uZWN0aW9uSWQpLnB1c2gobWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKlxuXHQgKiBSZXRyaWV2ZSBtZXNzYWdlcyBmcm9tIGxvc3QgbWVzc2FnZSBzdG9yZVxuXHQgKiBAaW50ZXJuYWxcblx0ICovIC8vVE9ETyBDaGFuZ2UgaXQgdG8gcHJpdmF0ZVxuICAgIF9nZXRNZXNzYWdlcyhjb25uZWN0aW9uSWQpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZXMgPSB0aGlzLl9sb3N0TWVzc2FnZXMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmIChtZXNzYWdlcykge1xuICAgICAgICAgICAgdGhpcy5fbG9zdE1lc3NhZ2VzLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLyoqXG5cdCAqIENvbm5lY3RzIHRvIHRoZSByZW1vdGUgcGVlciBzcGVjaWZpZWQgYnkgaWQgYW5kIHJldHVybnMgYSBkYXRhIGNvbm5lY3Rpb24uXG5cdCAqIEBwYXJhbSBwZWVyIFRoZSBicm9rZXJpbmcgSUQgb2YgdGhlIHJlbW90ZSBwZWVyICh0aGVpciB7QGFwaWxpbmsgUGVlci5pZH0pLlxuXHQgKiBAcGFyYW0gb3B0aW9ucyBmb3Igc3BlY2lmeWluZyBkZXRhaWxzIGFib3V0IFBlZXIgQ29ubmVjdGlvblxuXHQgKi8gY29ubmVjdChwZWVyLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHNlcmlhbGl6YXRpb246IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5kaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS53YXJuKFwiWW91IGNhbm5vdCBjb25uZWN0IHRvIGEgbmV3IFBlZXIgYmVjYXVzZSB5b3UgY2FsbGVkIC5kaXNjb25uZWN0KCkgb24gdGhpcyBQZWVyIGFuZCBlbmRlZCB5b3VyIGNvbm5lY3Rpb24gd2l0aCB0aGUgc2VydmVyLiBZb3UgY2FuIGNyZWF0ZSBhIG5ldyBQZWVyIHRvIHJlY29ubmVjdCwgb3IgY2FsbCByZWNvbm5lY3Qgb24gdGhpcyBwZWVyIGlmIHlvdSBiZWxpZXZlIGl0cyBJRCB0byBzdGlsbCBiZSBhdmFpbGFibGUuXCIpO1xuICAgICAgICAgICAgdGhpcy5lbWl0RXJyb3IoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmKS5EaXNjb25uZWN0ZWQsIFwiQ2Fubm90IGNvbm5lY3QgdG8gbmV3IFBlZXIgYWZ0ZXIgZGlzY29ubmVjdGluZyBmcm9tIHNlcnZlci5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YUNvbm5lY3Rpb24gPSBuZXcgdGhpcy5fc2VyaWFsaXplcnNbb3B0aW9ucy5zZXJpYWxpemF0aW9uXShwZWVyLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fYWRkQ29ubmVjdGlvbihwZWVyLCBkYXRhQ29ubmVjdGlvbik7XG4gICAgICAgIHJldHVybiBkYXRhQ29ubmVjdGlvbjtcbiAgICB9XG4gICAgLyoqXG5cdCAqIENhbGxzIHRoZSByZW1vdGUgcGVlciBzcGVjaWZpZWQgYnkgaWQgYW5kIHJldHVybnMgYSBtZWRpYSBjb25uZWN0aW9uLlxuXHQgKiBAcGFyYW0gcGVlciBUaGUgYnJva2VyaW5nIElEIG9mIHRoZSByZW1vdGUgcGVlciAodGhlaXIgcGVlci5pZCkuXG5cdCAqIEBwYXJhbSBzdHJlYW0gVGhlIGNhbGxlcidzIG1lZGlhIHN0cmVhbVxuXHQgKiBAcGFyYW0gb3B0aW9ucyBNZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGNvbm5lY3Rpb24sIHBhc3NlZCBpbiBieSB3aG9ldmVyIGluaXRpYXRlZCB0aGUgY29ubmVjdGlvbi5cblx0ICovIGNhbGwocGVlciwgc3RyZWFtLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkud2FybihcIllvdSBjYW5ub3QgY29ubmVjdCB0byBhIG5ldyBQZWVyIGJlY2F1c2UgeW91IGNhbGxlZCAuZGlzY29ubmVjdCgpIG9uIHRoaXMgUGVlciBhbmQgZW5kZWQgeW91ciBjb25uZWN0aW9uIHdpdGggdGhlIHNlcnZlci4gWW91IGNhbiBjcmVhdGUgYSBuZXcgUGVlciB0byByZWNvbm5lY3QuXCIpO1xuICAgICAgICAgICAgdGhpcy5lbWl0RXJyb3IoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmKS5EaXNjb25uZWN0ZWQsIFwiQ2Fubm90IGNvbm5lY3QgdG8gbmV3IFBlZXIgYWZ0ZXIgZGlzY29ubmVjdGluZyBmcm9tIHNlcnZlci5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5lcnJvcihcIlRvIGNhbGwgYSBwZWVyLCB5b3UgbXVzdCBwcm92aWRlIGEgc3RyZWFtIGZyb20geW91ciBicm93c2VyJ3MgYGdldFVzZXJNZWRpYWAuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lZGlhQ29ubmVjdGlvbiA9IG5ldyAoMCwgJDVjMWQwOGM3YzU3ZGE5YTMkZXhwb3J0JDRhODRlOTVhMjMyNGFjMjkpKHBlZXIsIHRoaXMsIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBfc3RyZWFtOiBzdHJlYW1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2FkZENvbm5lY3Rpb24ocGVlciwgbWVkaWFDb25uZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIG1lZGlhQ29ubmVjdGlvbjtcbiAgICB9XG4gICAgLyoqIEFkZCBhIGRhdGEvbWVkaWEgY29ubmVjdGlvbiB0byB0aGlzIHBlZXIuICovIF9hZGRDb25uZWN0aW9uKHBlZXJJZCwgY29ubmVjdGlvbikge1xuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBhZGQgY29ubmVjdGlvbiAke2Nvbm5lY3Rpb24udHlwZX06JHtjb25uZWN0aW9uLmNvbm5lY3Rpb25JZH0gdG8gcGVlcklkOiR7cGVlcklkfWApO1xuICAgICAgICBpZiAoIXRoaXMuX2Nvbm5lY3Rpb25zLmhhcyhwZWVySWQpKSB0aGlzLl9jb25uZWN0aW9ucy5zZXQocGVlcklkLCBbXSk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25zLmdldChwZWVySWQpLnB1c2goY29ubmVjdGlvbik7XG4gICAgfVxuICAgIC8vVE9ETyBzaG91bGQgYmUgcHJpdmF0ZVxuICAgIF9yZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbnMgPSB0aGlzLl9jb25uZWN0aW9ucy5nZXQoY29ubmVjdGlvbi5wZWVyKTtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNvbm5lY3Rpb25zLmluZGV4T2YoY29ubmVjdGlvbik7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSBjb25uZWN0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vcmVtb3ZlIGZyb20gbG9zdCBtZXNzYWdlc1xuICAgICAgICB0aGlzLl9sb3N0TWVzc2FnZXMuZGVsZXRlKGNvbm5lY3Rpb24uY29ubmVjdGlvbklkKTtcbiAgICB9XG4gICAgLyoqIFJldHJpZXZlIGEgZGF0YS9tZWRpYSBjb25uZWN0aW9uIGZvciB0aGlzIHBlZXIuICovIGdldENvbm5lY3Rpb24ocGVlcklkLCBjb25uZWN0aW9uSWQpIHtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbnMgPSB0aGlzLl9jb25uZWN0aW9ucy5nZXQocGVlcklkKTtcbiAgICAgICAgaWYgKCFjb25uZWN0aW9ucykgcmV0dXJuIG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY29ubmVjdGlvbiBvZiBjb25uZWN0aW9ucyl7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5jb25uZWN0aW9uSWQgPT09IGNvbm5lY3Rpb25JZCkgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF9kZWxheWVkQWJvcnQodHlwZSwgbWVzc2FnZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICB0aGlzLl9hYm9ydCh0eXBlLCBtZXNzYWdlKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuICAgIC8qKlxuXHQgKiBFbWl0cyBhbiBlcnJvciBtZXNzYWdlIGFuZCBkZXN0cm95cyB0aGUgUGVlci5cblx0ICogVGhlIFBlZXIgaXMgbm90IGRlc3Ryb3llZCBpZiBpdCdzIGluIGEgZGlzY29ubmVjdGVkIHN0YXRlLCBpbiB3aGljaCBjYXNlXG5cdCAqIGl0IHJldGFpbnMgaXRzIGRpc2Nvbm5lY3RlZCBzdGF0ZSBhbmQgaXRzIGV4aXN0aW5nIGNvbm5lY3Rpb25zLlxuXHQgKi8gX2Fib3J0KHR5cGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmVycm9yKFwiQWJvcnRpbmchXCIpO1xuICAgICAgICB0aGlzLmVtaXRFcnJvcih0eXBlLCBtZXNzYWdlKTtcbiAgICAgICAgaWYgKCF0aGlzLl9sYXN0U2VydmVySWQpIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICBlbHNlIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICAvKipcblx0ICogRGVzdHJveXMgdGhlIFBlZXI6IGNsb3NlcyBhbGwgYWN0aXZlIGNvbm5lY3Rpb25zIGFzIHdlbGwgYXMgdGhlIGNvbm5lY3Rpb25cblx0ICogdG8gdGhlIHNlcnZlci5cblx0ICpcblx0ICogOjo6Y2F1dGlvblxuXHQgKiBUaGlzIGNhbm5vdCBiZSB1bmRvbmU7IHRoZSByZXNwZWN0aXZlIHBlZXIgb2JqZWN0IHdpbGwgbm8gbG9uZ2VyIGJlIGFibGVcblx0ICogdG8gY3JlYXRlIG9yIHJlY2VpdmUgYW55IGNvbm5lY3Rpb25zLCBpdHMgSUQgd2lsbCBiZSBmb3JmZWl0ZWQgb24gdGhlIHNlcnZlcixcblx0ICogYW5kIGFsbCBvZiBpdHMgZGF0YSBhbmQgbWVkaWEgY29ubmVjdGlvbnMgd2lsbCBiZSBjbG9zZWQuXG5cdCAqIDo6OlxuXHQgKi8gZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coYERlc3Ryb3kgcGVlciB3aXRoIElEOiR7dGhpcy5pZH1gKTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KFwiY2xvc2VcIik7XG4gICAgfVxuICAgIC8qKiBEaXNjb25uZWN0cyBldmVyeSBjb25uZWN0aW9uIG9uIHRoaXMgcGVlci4gKi8gX2NsZWFudXAoKSB7XG4gICAgICAgIGZvciAoY29uc3QgcGVlcklkIG9mIHRoaXMuX2Nvbm5lY3Rpb25zLmtleXMoKSl7XG4gICAgICAgICAgICB0aGlzLl9jbGVhbnVwUGVlcihwZWVySWQpO1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbnMuZGVsZXRlKHBlZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIC8qKiBDbG9zZXMgYWxsIGNvbm5lY3Rpb25zIHRvIHRoaXMgcGVlci4gKi8gX2NsZWFudXBQZWVyKHBlZXJJZCkge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9ucyA9IHRoaXMuX2Nvbm5lY3Rpb25zLmdldChwZWVySWQpO1xuICAgICAgICBpZiAoIWNvbm5lY3Rpb25zKSByZXR1cm47XG4gICAgICAgIGZvciAoY29uc3QgY29ubmVjdGlvbiBvZiBjb25uZWN0aW9ucyljb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuXHQgKiBEaXNjb25uZWN0cyB0aGUgUGVlcidzIGNvbm5lY3Rpb24gdG8gdGhlIFBlZXJTZXJ2ZXIuIERvZXMgbm90IGNsb3NlIGFueVxuXHQgKiAgYWN0aXZlIGNvbm5lY3Rpb25zLlxuXHQgKiBXYXJuaW5nOiBUaGUgcGVlciBjYW4gbm8gbG9uZ2VyIGNyZWF0ZSBvciBhY2NlcHQgY29ubmVjdGlvbnMgYWZ0ZXIgYmVpbmdcblx0ICogIGRpc2Nvbm5lY3RlZC4gSXQgYWxzbyBjYW5ub3QgcmVjb25uZWN0IHRvIHRoZSBzZXJ2ZXIuXG5cdCAqLyBkaXNjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5kaXNjb25uZWN0ZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgY3VycmVudElkID0gdGhpcy5pZDtcbiAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhgRGlzY29ubmVjdCBwZWVyIHdpdGggSUQ6JHtjdXJyZW50SWR9YCk7XG4gICAgICAgIHRoaXMuX2Rpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX29wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5fbGFzdFNlcnZlcklkID0gY3VycmVudElkO1xuICAgICAgICB0aGlzLl9pZCA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdChcImRpc2Nvbm5lY3RlZFwiLCBjdXJyZW50SWQpO1xuICAgIH1cbiAgICAvKiogQXR0ZW1wdHMgdG8gcmVjb25uZWN0IHdpdGggdGhlIHNhbWUgSUQuXG5cdCAqXG5cdCAqIE9ubHkge0BhcGlsaW5rIFBlZXIuZGlzY29ubmVjdCB8IGRpc2Nvbm5lY3RlZCBwZWVyc30gY2FuIGJlIHJlY29ubmVjdGVkLlxuXHQgKiBEZXN0cm95ZWQgcGVlcnMgY2Fubm90IGJlIHJlY29ubmVjdGVkLlxuXHQgKiBJZiB0aGUgY29ubmVjdGlvbiBmYWlscyAoYXMgYW4gZXhhbXBsZSwgaWYgdGhlIHBlZXIncyBvbGQgSUQgaXMgbm93IHRha2VuKSxcblx0ICogdGhlIHBlZXIncyBleGlzdGluZyBjb25uZWN0aW9ucyB3aWxsIG5vdCBjbG9zZSwgYnV0IGFueSBhc3NvY2lhdGVkIGVycm9ycyBldmVudHMgd2lsbCBmaXJlLlxuXHQgKi8gcmVjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5kaXNjb25uZWN0ZWQgJiYgIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBBdHRlbXB0aW5nIHJlY29ubmVjdGlvbiB0byBzZXJ2ZXIgd2l0aCBJRCAke3RoaXMuX2xhc3RTZXJ2ZXJJZH1gKTtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZSh0aGlzLl9sYXN0U2VydmVySWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHBlZXIgY2Fubm90IHJlY29ubmVjdCB0byB0aGUgc2VydmVyLiBJdCBoYXMgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZC5cIik7XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmRpc2Nvbm5lY3RlZCAmJiAhdGhpcy5vcGVuKSAvLyBEbyBub3RoaW5nLiBXZSdyZSBzdGlsbCBjb25uZWN0aW5nIHRoZSBmaXJzdCB0aW1lLlxuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkuZXJyb3IoXCJJbiBhIGh1cnJ5PyBXZSdyZSBzdGlsbCB0cnlpbmcgdG8gbWFrZSB0aGUgaW5pdGlhbCBjb25uZWN0aW9uIVwiKTtcbiAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFBlZXIgJHt0aGlzLmlkfSBjYW5ub3QgcmVjb25uZWN0IGJlY2F1c2UgaXQgaXMgbm90IGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBzZXJ2ZXIhYCk7XG4gICAgfVxuICAgIC8qKlxuXHQgKiBHZXQgYSBsaXN0IG9mIGF2YWlsYWJsZSBwZWVyIElEcy4gSWYgeW91J3JlIHJ1bm5pbmcgeW91ciBvd24gc2VydmVyLCB5b3UnbGxcblx0ICogd2FudCB0byBzZXQgYWxsb3dfZGlzY292ZXJ5OiB0cnVlIGluIHRoZSBQZWVyU2VydmVyIG9wdGlvbnMuIElmIHlvdSdyZSB1c2luZ1xuXHQgKiB0aGUgY2xvdWQgc2VydmVyLCBlbWFpbCB0ZWFtQHBlZXJqcy5jb20gdG8gZ2V0IHRoZSBmdW5jdGlvbmFsaXR5IGVuYWJsZWQgZm9yXG5cdCAqIHlvdXIga2V5LlxuXHQgKi8gbGlzdEFsbFBlZXJzKGNiID0gKF8pPT57fSkge1xuICAgICAgICB0aGlzLl9hcGkubGlzdEFsbFBlZXJzKCkudGhlbigocGVlcnMpPT5jYihwZWVycykpLmNhdGNoKChlcnJvcik9PnRoaXMuX2Fib3J0KCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkOTU0N2FhYTJlMzkwMzBmZikuU2VydmVyRXJyb3IsIGVycm9yKSk7XG4gICAgfVxufVxuXG5cblxuXG5cblxuY2xhc3MgJDIwZGJlNjgxNDlkN2FhZDkkZXhwb3J0JDcyYWE0NDYxMmUyMjAwY2QgZXh0ZW5kcyAoMCwgJDYzNjZjNGNhMTYxYmMyOTckZXhwb3J0JGQzNjVmN2FkOWQ3ZGY5YzkpIHtcbiAgICBjb25zdHJ1Y3RvcihwZWVySWQsIHByb3ZpZGVyLCBvcHRpb25zKXtcbiAgICAgICAgc3VwZXIocGVlcklkLCBwcm92aWRlciwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHJlbGlhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9DSFVOS19TSVpFID0gMzI3Njg7XG4gICAgICAgIHRoaXMuX3NwbGl0U3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IChjaHVuaywgY29udHJvbGxlcik9PntcbiAgICAgICAgICAgICAgICBmb3IobGV0IHNwbGl0ID0gMDsgc3BsaXQgPCBjaHVuay5sZW5ndGg7IHNwbGl0ICs9IHRoaXMuX0NIVU5LX1NJWkUpY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLnN1YmFycmF5KHNwbGl0LCBzcGxpdCArIHRoaXMuX0NIVU5LX1NJWkUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3Jhd1NlbmRTdHJlYW0gPSBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgd3JpdGU6IGFzeW5jIChjaHVuaywgY29udHJvbGxlcik9PntcbiAgICAgICAgICAgICAgICBjb25zdCBvcGVuRXZlbnQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PnRoaXMuZGF0YUNoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcihcImJ1ZmZlcmVkYW1vdW50bG93XCIsIHJlc29sdmUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGNhbiBzZW5kIHRoZSBjaHVuayBub3csIHNlbmQgaXRcbiAgICAgICAgICAgICAgICAvLyBpZiBub3QsIHdlIHdhaXQgdW50aWwgYXQgbGVhc3QgaGFsZiBvZiB0aGUgc2VuZGluZyBidWZmZXIgaXMgZnJlZSBhZ2FpblxuICAgICAgICAgICAgICAgIGF3YWl0ICh0aGlzLmRhdGFDaGFubmVsLmJ1ZmZlcmVkQW1vdW50IDw9ICgwLCAkNjM2NmM0Y2ExNjFiYzI5NyRleHBvcnQkZDM2NWY3YWQ5ZDdkZjljOSkuTUFYX0JVRkZFUkVEX0FNT1VOVCAtIGNodW5rLmJ5dGVMZW5ndGggfHwgb3BlbkV2ZW50KTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aGF0IGNhbiBnbyB3cm9uZyBoZXJlP1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5uZWwuc2VuZChjaHVuayk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkuZXJyb3IoYERDIzoke3RoaXMuY29ubmVjdGlvbklkfSBFcnJvciB3aGVuIHNlbmRpbmc6YCwgZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndyaXRlciA9IHRoaXMuX3NwbGl0U3RyZWFtLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICAgICAgICB0aGlzLl9yYXdSZWFkU3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHN0YXJ0OiAoY29udHJvbGxlcik9PntcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJvcGVuXCIsICgpPT57XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGUpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zcGxpdFN0cmVhbS5yZWFkYWJsZS5waXBlVG8odGhpcy5fcmF3U2VuZFN0cmVhbSk7XG4gICAgfVxuICAgIF9pbml0aWFsaXplRGF0YUNoYW5uZWwoZGMpIHtcbiAgICAgICAgc3VwZXIuX2luaXRpYWxpemVEYXRhQ2hhbm5lbChkYyk7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWwuYmluYXJ5VHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCA9ICgwLCAkNjM2NmM0Y2ExNjFiYzI5NyRleHBvcnQkZDM2NWY3YWQ5ZDdkZjljOSkuTUFYX0JVRkZFUkVEX0FNT1VOVCAvIDI7XG4gICAgfVxufVxuXG5cbmNsYXNzICQ2ZTM5MjMwYWIzNjM5NmFkJGV4cG9ydCQ4MGY1ZGUxYTY2YzRkNjI0IGV4dGVuZHMgKDAsICQyMGRiZTY4MTQ5ZDdhYWQ5JGV4cG9ydCQ3MmFhNDQ2MTJlMjIwMGNkKSB7XG4gICAgY29uc3RydWN0b3IocGVlcklkLCBwcm92aWRlciwgb3B0aW9ucyl7XG4gICAgICAgIHN1cGVyKHBlZXJJZCwgcHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNlcmlhbGl6YXRpb24gPSBcIk1zZ1BhY2tcIjtcbiAgICAgICAgdGhpcy5fZW5jb2RlciA9IG5ldyAoMCwgJGdDY2JZJEVuY29kZXIpKCk7XG4gICAgICAgIChhc3luYyAoKT0+e1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBtc2cgb2YgKDAsICRnQ2NiWSRkZWNvZGVNdWx0aVN0cmVhbSkodGhpcy5fcmF3UmVhZFN0cmVhbSkpe1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBpZiAobXNnLl9fcGVlckRhdGE/LnR5cGUgPT09IFwiY2xvc2VcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGF0YVwiLCBtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBfc2VuZChkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlci53cml0ZSh0aGlzLl9lbmNvZGVyLmVuY29kZShkYXRhKSk7XG4gICAgfVxufVxuXG5cbmNsYXNzICQxZTBhZmYxNmJlMmMzMjhlJGV4cG9ydCRkNzJjN2JmOGVlZjUwODUzIGV4dGVuZHMgKDAsICQ0MTYyNjBiY2UzMzdkZjkwJGV4cG9ydCRlY2QxZmMxMzZjNDIyNDQ4KSB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLl9zZXJpYWxpemVycyA9IHtcbiAgICAgICAgICAgIE1zZ1BhY2s6ICQ2ZTM5MjMwYWIzNjM5NmFkJGV4cG9ydCQ4MGY1ZGUxYTY2YzRkNjI0LFxuICAgICAgICAgICAgZGVmYXVsdDogKDAsICQ2ZTM5MjMwYWIzNjM5NmFkJGV4cG9ydCQ4MGY1ZGUxYTY2YzRkNjI0KVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuXG5cblxuXG5cblxudmFyICRkZDAxODdkN2YyOGUzODZmJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkgPSAoMCwgJDQxNjI2MGJjZTMzN2RmOTAkZXhwb3J0JGVjZDFmYzEzNmM0MjI0NDgpO1xuXG5cbmV4cG9ydCB7JGRkMDE4N2Q3ZjI4ZTM4NmYkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSBhcyBkZWZhdWx0LCAkNGY0MTM0MTU2YzQ0NjM5MiRleHBvcnQkN2RlYmI1MGVmMTFkNWUwYiBhcyB1dGlsLCAkYTIyOWJlZGJjYWE2Y2EyMyRleHBvcnQkZmY3YzlkNGMxMWQ5NGU4YiBhcyBCdWZmZXJlZENvbm5lY3Rpb24sICQyMGRiZTY4MTQ5ZDdhYWQ5JGV4cG9ydCQ3MmFhNDQ2MTJlMjIwMGNkIGFzIFN0cmVhbUNvbm5lY3Rpb24sICQ2ZTM5MjMwYWIzNjM5NmFkJGV4cG9ydCQ4MGY1ZGUxYTY2YzRkNjI0IGFzIE1zZ1BhY2ssICQ0MTYyNjBiY2UzMzdkZjkwJGV4cG9ydCRlY2QxZmMxMzZjNDIyNDQ4IGFzIFBlZXIsICQxZTBhZmYxNmJlMmMzMjhlJGV4cG9ydCRkNzJjN2JmOGVlZjUwODUzIGFzIE1zZ1BhY2tQZWVyLCAkMjM3NzlkMTg4MTE1N2ExOCRleHBvcnQkOTg4NzE4ODJmNDkyZGU4MiBhcyBQZWVyRXJyb3IsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzMTU3ZDU3YjQxMzVlM2JjIGFzIENvbm5lY3Rpb25UeXBlLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkOTU0N2FhYTJlMzkwMzBmZiBhcyBQZWVyRXJyb3JUeXBlLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkNzk3NDkzNTY4NjE0OTY4NiBhcyBCYXNlQ29ubmVjdGlvbkVycm9yVHlwZSwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDQ5YWU4MDBjMTE0ZGY0MWQgYXMgRGF0YUNvbm5lY3Rpb25FcnJvclR5cGUsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ4OWY1MDdjZjk4NmE5NDcgYXMgU2VyaWFsaXphdGlvblR5cGUsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzYjVjNGE0YjYzNTRmMDIzIGFzIFNvY2tldEV2ZW50VHlwZSwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JGFkYjRhMTc1NGRhNmYxMGQgYXMgU2VydmVyTWVzc2FnZVR5cGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVuZGxlci5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/peerjs/dist/bundler.mjs\n");

/***/ })

};
;